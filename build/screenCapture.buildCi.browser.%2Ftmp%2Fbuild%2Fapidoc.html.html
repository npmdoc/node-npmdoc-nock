<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/node-nock/nock#readme">nock (v9.0.13)</a>
</h1>
<h4>HTTP Server mocking for Node.js</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.nock">module nock</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.nock">
            function <span class="apidocSignatureSpan"></span>nock
            <span class="apidocSignatureSpan">(basePath, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.activate">
            function <span class="apidocSignatureSpan">nock.</span>activate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.activeMocks">
            function <span class="apidocSignatureSpan">nock.</span>activeMocks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.back">
            function <span class="apidocSignatureSpan">nock.</span>back
            <span class="apidocSignatureSpan">(fixtureName, options, nockedFn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.cleanAll">
            function <span class="apidocSignatureSpan">nock.</span>cleanAll
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.define">
            function <span class="apidocSignatureSpan">nock.</span>define
            <span class="apidocSignatureSpan">(nockDefs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.delayed_body">
            function <span class="apidocSignatureSpan">nock.</span>delayed_body
            <span class="apidocSignatureSpan">(ms, body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.disableNetConnect">
            function <span class="apidocSignatureSpan">nock.</span>disableNetConnect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.enableNetConnect">
            function <span class="apidocSignatureSpan">nock.</span>enableNetConnect
            <span class="apidocSignatureSpan">(matcher)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.intercept">
            function <span class="apidocSignatureSpan">nock.</span>intercept
            <span class="apidocSignatureSpan">(key, interceptor, scope, scopeOptions, host)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.interceptor">
            function <span class="apidocSignatureSpan">nock.</span>interceptor
            <span class="apidocSignatureSpan">(scope, uri, method, requestBody, interceptorOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.isActive">
            function <span class="apidocSignatureSpan">nock.</span>isActive
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.isDone">
            function <span class="apidocSignatureSpan">nock.</span>isDone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.load">
            function <span class="apidocSignatureSpan">nock.</span>load
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.loadDefs">
            function <span class="apidocSignatureSpan">nock.</span>loadDefs
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.pendingMocks">
            function <span class="apidocSignatureSpan">nock.</span>pendingMocks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.removeInterceptor">
            function <span class="apidocSignatureSpan">nock.</span>removeInterceptor
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.restore">
            function <span class="apidocSignatureSpan">nock.</span>restore
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.scope">
            function <span class="apidocSignatureSpan">nock.</span>scope
            <span class="apidocSignatureSpan">(basePath, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.socket">
            function <span class="apidocSignatureSpan">nock.</span>socket
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">nock.</span>common</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">nock.</span>delayed_body.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">nock.</span>emitter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">nock.</span>interceptor.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">nock.</span>recorder</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">nock.</span>socket.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.nock.back">module nock.back</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.back.back">
            function <span class="apidocSignatureSpan">nock.</span>back
            <span class="apidocSignatureSpan">(fixtureName, options, nockedFn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.back.setMode">
            function <span class="apidocSignatureSpan">nock.back.</span>setMode
            <span class="apidocSignatureSpan">(mode)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">nock.back.</span>fixtures</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">nock.back.</span>currentMode</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.nock.common">module nock.common</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.common.contentEncoding">
            function <span class="apidocSignatureSpan">nock.common.</span>contentEncoding
            <span class="apidocSignatureSpan">(headers, encoder)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.common.deleteHeadersField">
            function <span class="apidocSignatureSpan">nock.common.</span>deleteHeadersField
            <span class="apidocSignatureSpan">(headers, fieldNameToDelete)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.common.formatQueryValue">
            function <span class="apidocSignatureSpan">nock.common.</span>formatQueryValue
            <span class="apidocSignatureSpan">(key, value, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.common.headersArrayToObject">
            function <span class="apidocSignatureSpan">nock.common.</span>headersArrayToObject
            <span class="apidocSignatureSpan">(rawHeaders)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.common.headersFieldNamesToLowerCase">
            function <span class="apidocSignatureSpan">nock.common.</span>headersFieldNamesToLowerCase
            <span class="apidocSignatureSpan">(headers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.common.headersFieldsArrayToLowerCase">
            function <span class="apidocSignatureSpan">nock.common.</span>headersFieldsArrayToLowerCase
            <span class="apidocSignatureSpan">(headers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.common.isBinaryBuffer">
            function <span class="apidocSignatureSpan">nock.common.</span>isBinaryBuffer
            <span class="apidocSignatureSpan">(buffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.common.isContentEncoded">
            function <span class="apidocSignatureSpan">nock.common.</span>isContentEncoded
            <span class="apidocSignatureSpan">(headers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.common.isJSONContent">
            function <span class="apidocSignatureSpan">nock.common.</span>isJSONContent
            <span class="apidocSignatureSpan">(headers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.common.isStream">
            function <span class="apidocSignatureSpan">nock.common.</span>isStream
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.common.matchStringOrRegexp">
            function <span class="apidocSignatureSpan">nock.common.</span>matchStringOrRegexp
            <span class="apidocSignatureSpan">(target, pattern)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.common.mergeChunks">
            function <span class="apidocSignatureSpan">nock.common.</span>mergeChunks
            <span class="apidocSignatureSpan">(chunks)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.common.normalizeRequestOptions">
            function <span class="apidocSignatureSpan">nock.common.</span>normalizeRequestOptions
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.common.overrideRequests">
            function <span class="apidocSignatureSpan">nock.common.</span>overrideRequests
            <span class="apidocSignatureSpan">(newRequest)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.common.percentDecode">
            function <span class="apidocSignatureSpan">nock.common.</span>percentDecode
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.common.percentEncode">
            function <span class="apidocSignatureSpan">nock.common.</span>percentEncode
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.common.restoreOverriddenRequests">
            function <span class="apidocSignatureSpan">nock.common.</span>restoreOverriddenRequests
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.common.stringifyRequest">
            function <span class="apidocSignatureSpan">nock.common.</span>stringifyRequest
            <span class="apidocSignatureSpan">(options, body)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.nock.delayed_body">module nock.delayed_body</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.delayed_body.delayed_body">
            function <span class="apidocSignatureSpan">nock.</span>delayed_body
            <span class="apidocSignatureSpan">(ms, body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.delayed_body.super_">
            function <span class="apidocSignatureSpan">nock.delayed_body.</span>super_
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.nock.delayed_body.prototype">module nock.delayed_body.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.delayed_body.prototype._transform">
            function <span class="apidocSignatureSpan">nock.delayed_body.prototype.</span>_transform
            <span class="apidocSignatureSpan">(chunk, encoding, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.nock.intercept">module nock.intercept</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.intercept.intercept">
            function <span class="apidocSignatureSpan">nock.</span>intercept
            <span class="apidocSignatureSpan">(key, interceptor, scope, scopeOptions, host)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.intercept.activate">
            function <span class="apidocSignatureSpan">nock.intercept.</span>activate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.intercept.activeMocks">
            function <span class="apidocSignatureSpan">nock.intercept.</span>activeMocks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.intercept.disableNetConnect">
            function <span class="apidocSignatureSpan">nock.intercept.</span>disableNetConnect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.intercept.enableNetConnect">
            function <span class="apidocSignatureSpan">nock.intercept.</span>enableNetConnect
            <span class="apidocSignatureSpan">(matcher)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.intercept.isActive">
            function <span class="apidocSignatureSpan">nock.intercept.</span>isActive
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.intercept.isDone">
            function <span class="apidocSignatureSpan">nock.intercept.</span>isDone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.intercept.isOn">
            function <span class="apidocSignatureSpan">nock.intercept.</span>isOn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.intercept.overrideClientRequest">
            function <span class="apidocSignatureSpan">nock.intercept.</span>overrideClientRequest
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.intercept.pendingMocks">
            function <span class="apidocSignatureSpan">nock.intercept.</span>pendingMocks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.intercept.removeAll">
            function <span class="apidocSignatureSpan">nock.intercept.</span>removeAll
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.intercept.removeInterceptor">
            function <span class="apidocSignatureSpan">nock.intercept.</span>removeInterceptor
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.intercept.restoreOverriddenClientRequest">
            function <span class="apidocSignatureSpan">nock.intercept.</span>restoreOverriddenClientRequest
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.nock.interceptor">module nock.interceptor</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.interceptor.interceptor">
            function <span class="apidocSignatureSpan">nock.</span>interceptor
            <span class="apidocSignatureSpan">(scope, uri, method, requestBody, interceptorOptions)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.nock.interceptor.prototype">module nock.interceptor.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.interceptor.prototype.basicAuth">
            function <span class="apidocSignatureSpan">nock.interceptor.prototype.</span>basicAuth
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.interceptor.prototype.delay">
            function <span class="apidocSignatureSpan">nock.interceptor.prototype.</span>delay
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.interceptor.prototype.delayBody">
            function <span class="apidocSignatureSpan">nock.interceptor.prototype.</span>delayBody
            <span class="apidocSignatureSpan">(ms)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.interceptor.prototype.delayConnection">
            function <span class="apidocSignatureSpan">nock.interceptor.prototype.</span>delayConnection
            <span class="apidocSignatureSpan">(ms)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.interceptor.prototype.discard">
            function <span class="apidocSignatureSpan">nock.interceptor.prototype.</span>discard
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.interceptor.prototype.filteringPath">
            function <span class="apidocSignatureSpan">nock.interceptor.prototype.</span>filteringPath
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.interceptor.prototype.getTotalDelay">
            function <span class="apidocSignatureSpan">nock.interceptor.prototype.</span>getTotalDelay
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.interceptor.prototype.match">
            function <span class="apidocSignatureSpan">nock.interceptor.prototype.</span>match
            <span class="apidocSignatureSpan">(options, body, hostNameOnly)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.interceptor.prototype.matchHeader">
            function <span class="apidocSignatureSpan">nock.interceptor.prototype.</span>matchHeader
            <span class="apidocSignatureSpan">(name, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.interceptor.prototype.matchIndependentOfBody">
            function <span class="apidocSignatureSpan">nock.interceptor.prototype.</span>matchIndependentOfBody
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.interceptor.prototype.once">
            function <span class="apidocSignatureSpan">nock.interceptor.prototype.</span>once
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.interceptor.prototype.optionally">
            function <span class="apidocSignatureSpan">nock.interceptor.prototype.</span>optionally
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.interceptor.prototype.query">
            function <span class="apidocSignatureSpan">nock.interceptor.prototype.</span>query
            <span class="apidocSignatureSpan">(queries)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.interceptor.prototype.reply">
            function <span class="apidocSignatureSpan">nock.interceptor.prototype.</span>reply
            <span class="apidocSignatureSpan">(statusCode, body, rawHeaders)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.interceptor.prototype.replyWithError">
            function <span class="apidocSignatureSpan">nock.interceptor.prototype.</span>replyWithError
            <span class="apidocSignatureSpan">(errorMessage)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.interceptor.prototype.replyWithFile">
            function <span class="apidocSignatureSpan">nock.interceptor.prototype.</span>replyWithFile
            <span class="apidocSignatureSpan">(statusCode, filePath, headers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.interceptor.prototype.reqheaderMatches">
            function <span class="apidocSignatureSpan">nock.interceptor.prototype.</span>reqheaderMatches
            <span class="apidocSignatureSpan">(options, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.interceptor.prototype.socketDelay">
            function <span class="apidocSignatureSpan">nock.interceptor.prototype.</span>socketDelay
            <span class="apidocSignatureSpan">(ms)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.interceptor.prototype.thrice">
            function <span class="apidocSignatureSpan">nock.interceptor.prototype.</span>thrice
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.interceptor.prototype.times">
            function <span class="apidocSignatureSpan">nock.interceptor.prototype.</span>times
            <span class="apidocSignatureSpan">(newCounter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.interceptor.prototype.twice">
            function <span class="apidocSignatureSpan">nock.interceptor.prototype.</span>twice
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.nock.recorder">module nock.recorder</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.recorder.clear">
            function <span class="apidocSignatureSpan">nock.recorder.</span>clear
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.recorder.play">
            function <span class="apidocSignatureSpan">nock.recorder.</span>play
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.recorder.rec">
            function <span class="apidocSignatureSpan">nock.recorder.</span>rec
            <span class="apidocSignatureSpan">(rec_options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.nock.scope">module nock.scope</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.scope.scope">
            function <span class="apidocSignatureSpan">nock.</span>scope
            <span class="apidocSignatureSpan">(basePath, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.scope.activate">
            function <span class="apidocSignatureSpan">nock.scope.</span>activate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.scope.activeMocks">
            function <span class="apidocSignatureSpan">nock.scope.</span>activeMocks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.scope.back">
            function <span class="apidocSignatureSpan">nock.scope.</span>back
            <span class="apidocSignatureSpan">(fixtureName, options, nockedFn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.scope.cleanAll">
            function <span class="apidocSignatureSpan">nock.scope.</span>cleanAll
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.scope.define">
            function <span class="apidocSignatureSpan">nock.scope.</span>define
            <span class="apidocSignatureSpan">(nockDefs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.scope.disableNetConnect">
            function <span class="apidocSignatureSpan">nock.scope.</span>disableNetConnect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.scope.enableNetConnect">
            function <span class="apidocSignatureSpan">nock.scope.</span>enableNetConnect
            <span class="apidocSignatureSpan">(matcher)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.scope.isActive">
            function <span class="apidocSignatureSpan">nock.scope.</span>isActive
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.scope.isDone">
            function <span class="apidocSignatureSpan">nock.scope.</span>isDone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.scope.load">
            function <span class="apidocSignatureSpan">nock.scope.</span>load
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.scope.loadDefs">
            function <span class="apidocSignatureSpan">nock.scope.</span>loadDefs
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.scope.pendingMocks">
            function <span class="apidocSignatureSpan">nock.scope.</span>pendingMocks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.scope.removeInterceptor">
            function <span class="apidocSignatureSpan">nock.scope.</span>removeInterceptor
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.scope.restore">
            function <span class="apidocSignatureSpan">nock.scope.</span>restore
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">nock.scope.</span>emitter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">nock.scope.</span>recorder</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.nock.socket">module nock.socket</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.socket.socket">
            function <span class="apidocSignatureSpan">nock.</span>socket
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.socket.super_">
            function <span class="apidocSignatureSpan">nock.socket.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.nock.socket.prototype">module nock.socket.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.socket.prototype.applyDelay">
            function <span class="apidocSignatureSpan">nock.socket.prototype.</span>applyDelay
            <span class="apidocSignatureSpan">(delayMs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.socket.prototype.destroy">
            function <span class="apidocSignatureSpan">nock.socket.prototype.</span>destroy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.socket.prototype.getPeerCertificate">
            function <span class="apidocSignatureSpan">nock.socket.prototype.</span>getPeerCertificate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nock.socket.prototype.setTimeout">
            function <span class="apidocSignatureSpan">nock.socket.prototype.</span>setTimeout
            <span class="apidocSignatureSpan">(timeoutMs, fn)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nock" id="apidoc.module.nock">module nock</a></h1>


    <h2>
        <a href="#apidoc.element.nock.nock" id="apidoc.element.nock.nock">
        function <span class="apidocSignatureSpan"></span>nock
        <span class="apidocSignatureSpan">(basePath, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function startScope(basePath, options) {
  return new Scope(basePath, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.activate" id="apidoc.element.nock.activate">
        function <span class="apidocSignatureSpan">nock.</span>activate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function activate() {

  if(originalClientRequest) {
    throw new Error('Nock already active');
  }

  overrideClientRequest();

  // ----- Overriding http.request and https.request:

  common.overrideRequests(function(proto, overriddenRequest, options, callback) {
    //  NOTE: overriddenRequest is already bound to its module.
    var req,
        res;

    if (typeof options === 'string') {
      options = parse(options);
    }
    options.proto = proto;

    var interceptors = interceptorsFor(options)

    if (isOn() &amp;&amp; interceptors) {
      var matches = false,
          allowUnmocked = false;

      matches = !! _.find(interceptors, function(interceptor) {
        return interceptor.matchIndependentOfBody(options);
      });

      allowUnmocked = !! _.find(interceptors, function(interceptor) {
        return interceptor.options.allowUnmocked;
      });

      if (! matches &amp;&amp; allowUnmocked) {
        if (proto === 'https') {
          var ClientRequest = http.ClientRequest;
          http.ClientRequest = originalClientRequest;
          req = overriddenRequest(options, callback);
          http.ClientRequest = ClientRequest;
        } else {
          req = overriddenRequest(options, callback);
        }
        globalEmitter.emit('no match', req);
        return req;
      }

      //  NOTE: Since we already overrode the http.ClientRequest we are in fact constructing
      //    our own OverriddenClientRequest.
      req = new http.ClientRequest(options);

      res = RequestOverrider(req, options, interceptors, remove);
      if (callback) {
        res.on('response', callback);
      }
      return req;
    } else {
      globalEmitter.emit('no match', options);
      if (isOff() || isEnabledForNetConnect(options)) {
        return overriddenRequest(options, callback);
      } else {
        var error = new NetConnectNotAllowedError(options.host, options.path);
        return new ErroringClientRequest(error);
      }
    }
  });

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var wild = {


setup: function () {
  nock.cleanAll();
  recorder.restore();
  nock.<span class="apidocCodeKeywordSpan">activate</span>();
  nock.enableNetConnect();
},


start: function () {
  return load(); //don't load anything but get correct context
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.activeMocks" id="apidoc.element.nock.activeMocks">
        function <span class="apidocSignatureSpan">nock.</span>activeMocks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function activeMocks() {
  return _.flatten(_.map(interceptorScopes(), function(scope) {
    return scope.activeMocks();
  }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* 8.2.0
* Add changelog to the dev dependencies
* Ignore browserify-bundle.js
* Update browserify-bundle.js
* Merge pull request [#723](https://github.com/node-nock/nock/issues/723) from pimterry/optional-mocks
  Add optionally() and make isDone and pendingMocks consistent.
* Include all review markup changes in browserify-bundle
* Add .<span class="apidocCodeKeywordSpan">activeMocks</span>() to recreate previous .pendingMocks() behaviour
* Add times+optional and persist+optional tests
* Document assumption in pendingMocks()
* Clarify optional mock behaviour a little in README
* Merge pull request [#721](https://github.com/node-nock/nock/issues/721) from pimterry/removeInterceptor-from-pending
  Update PendingMocks when an interceptor is removed
* Merge pull request [#722](https://github.com/node-nock/nock/issues/722) from Ginden/no-garbage-in-npm
  Removed coverage folder from npm
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.back" id="apidoc.element.nock.back">
        function <span class="apidocSignatureSpan">nock.</span>back
        <span class="apidocSignatureSpan">(fixtureName, options, nockedFn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Back(fixtureName, options, nockedFn) {
  if(!Back.fixtures) {
    throw new Error(  'Back requires nock.back.fixtures to be set\n' +
                      'Ex:\n' +
                      '\trequire(nock).back.fixtures = \'/path/to/fixures/\'');
  }

  if( arguments.length === 2 ) {
    nockedFn = options;
    options = {};
  }

  _mode.setup();

  var fixture = path.join(Back.fixtures, fixtureName)
    , context = _mode.start(fixture, options);


  var nockDone = function () {
    _mode.finish(fixture, options, context);
  };

  debug('context:', context);

  nockedFn.call(context, nockDone);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.cleanAll" id="apidoc.element.nock.cleanAll">
        function <span class="apidocSignatureSpan">nock.</span>cleanAll
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cleanAll() {
  globalIntercept.removeAll();
  return module.exports;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  * [Path filtering](#path-filtering)
  * [Request Body filtering](#request-body-filtering)
  * [Request Headers Matching](#request-headers-matching)
  * [Optional Requests](#optional-requests)
  * [Allow __unmocked__ requests on a mocked hostname](#allow-__unmocked__-requests-on-a-mocked-hostname)
- [Expectations](#expectations)
  * [.isDone()](#isdone)
  * [.<span class="apidocCodeKeywordSpan">cleanAll</span>()](#cleanall)
  * [.persist()](#persist)
  * [.pendingMocks()](#pendingmocks)
  * [.activeMocks()](#activemocks)
- [Logging](#logging)
- [Restoring](#restoring)
- [Turning Nock Off (experimental!)](#turning-nock-off-experimental)
- [Enable/Disable real HTTP request](#enabledisable-real-http-request)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.define" id="apidoc.element.nock.define">
        function <span class="apidocSignatureSpan">nock.</span>define
        <span class="apidocSignatureSpan">(nockDefs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function define(nockDefs) {

  var nocks     = [];

  nockDefs.forEach(function(nockDef) {

    var nscope     = getScopeFromDefinition(nockDef)
      , npath      = nockDef.path
      , method     = nockDef.method.toLowerCase() || "get"
      , status     = getStatusFromDefinition(nockDef)
      , rawHeaders = nockDef.rawHeaders || []
      , reqheaders = nockDef.reqheaders || {}
      , body       = nockDef.body       || ''
      , options    = nockDef.options    || {};

    //  We use request headers for both filtering (see below) and mocking.
    //  Here we are setting up mocked request headers but we don't want to
    //  be changing the user's options object so we clone it first.
    options = _.clone(options) || {};
    options.reqheaders = reqheaders;

    //  Response is not always JSON as it could be a string or binary data or
    //  even an array of binary buffers (e.g. when content is enconded)
    var response;
    if (!nockDef.response) {
      response = '';
    } else {
      response = _.isString(nockDef.response) ? tryJsonParse(nockDef.response) : nockDef.response;
    }

    var nock;
    if (body==="*") {
      nock = startScope(nscope, options).filteringRequestBody(function() {
        return "*";
      })[method](npath, "*").reply(status, response, rawHeaders);
    } else {
      nock = startScope(nscope, options);
      //  If request headers were specified filter by them.
      if (_.size(reqheaders) &gt; 0) {
        for (var k in reqheaders) {
          nock.matchHeader(k, reqheaders[k]);
        }
      }
      if (nockDef.filteringRequestBody) {
        nock.filteringRequestBody(nockDef.filteringRequestBody);
      }
      nock.intercept(npath, method, body).reply(status, response, rawHeaders);
    }

    nocks.push(nock);

  });

  return nocks;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return body.replace(/(timestamp):([0-9]+)/g, function(match, key, value) {
    return key + ':' + recordedTimestamp;
  });
};
});
```

Alternatively, if you need to pre-process the captured nock definitions before using them (e.g. to add scope filtering) then you
 can use `nock.loadDefs(path)` and `nock.<span class="apidocCodeKeywordSpan">define</span>(nockDefs)`. Shown here is scope filtering
 for Dropbox node module which constantly changes the subdomain to which it sends the requests:

```js
//  Pre-process the nock definitions as scope filtering has to be defined before the nocks are defined (due to its very hacky nature
).
var nockDefs = nock.loadDefs(pathToJson);
nockDefs.forEach(function(def) {
//  Do something with the definition object e.g. scope filtering.
def.options = def.options || {};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.delayed_body" id="apidoc.element.nock.delayed_body">
        function <span class="apidocSignatureSpan">nock.</span>delayed_body
        <span class="apidocSignatureSpan">(ms, body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DelayedBody(ms, body) {
  Transform.call(this);

  var self = this;
  var data = '';
  var ended = false;

  if (common.isStream(body)) {
    body.on('data', function (chunk) {
      data += Buffer.isBuffer(chunk) ? chunk.toString() : chunk;
    });

    body.once('end', function () {
      ended = true;
    });

    body.resume();
  }

  setTimeout(function () {
    if (common.isStream(body) &amp;&amp; !ended) {
      body.once('end', function () {
        self.end(data);
      });
    } else {
      self.end(data || body);
    }
  }, ms);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.disableNetConnect" id="apidoc.element.nock.disableNetConnect">
        function <span class="apidocSignatureSpan">nock.</span>disableNetConnect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function disableNetConnect() {
  allowNetConnect = undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
# Enable/Disable real HTTP request

As default, if you do not mock a host, a real HTTP request will do, but sometimes you should not permit real HTTP request, so...

For disabling real http requests.

```js
nock.<span class="apidocCodeKeywordSpan">disableNetConnect</span>();
```

So, if you try to request any host not 'nocked', it will thrown an `NetConnectNotAllowedError`.

```js
nock.disableNetConnect();
var req = http.get('http://google.com/');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.enableNetConnect" id="apidoc.element.nock.enableNetConnect">
        function <span class="apidocSignatureSpan">nock.</span>enableNetConnect
        <span class="apidocSignatureSpan">(matcher)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function enableNetConnect(matcher) {
  if (_.isString(matcher)) {
    allowNetConnect = new RegExp(matcher);
  } else if (_.isObject(matcher) &amp;&amp; _.isFunction(matcher.test)) {
    allowNetConnect = matcher;
  } else {
    allowNetConnect = /.*/;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// This code will log a NetConnectNotAllowedError with message:
// Nock: Not allow net connect for "google.com:80"
```

For enabling real HTTP requests (the default behaviour).

```js
nock.<span class="apidocCodeKeywordSpan">enableNetConnect</span>();
```

You could allow real HTTP request for certain host names by providing a string or a regular expression for the hostname:

```js
// using a string
nock.enableNetConnect('amazon.com');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.intercept" id="apidoc.element.nock.intercept">
        function <span class="apidocSignatureSpan">nock.</span>intercept
        <span class="apidocSignatureSpan">(key, interceptor, scope, scopeOptions, host)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function add(key, interceptor, scope, scopeOptions, host) {
  if (! allInterceptors.hasOwnProperty(key)) {
    allInterceptors[key] = { key: key, scopes: [] };
  }
  interceptor.__nock_scope = scope;

  //  We need scope's key and scope options for scope filtering function (if defined)
  interceptor.__nock_scopeKey = key;
  interceptor.__nock_scopeOptions = scopeOptions;
  //  We need scope's host for setting correct request headers for filtered scopes.
  interceptor.__nock_scopeHost = host;
  interceptor.interceptionCounter = 0;

  allInterceptors[key].scopes.push(interceptor);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  .reply(200, { hello: 'world' });
```

## HTTP Verbs

Nock supports any HTTP verb, and it has convenience methods for the GET, POST, PUT, HEAD, DELETE, PATCH and MERGE HTTP verbs.

You can intercept any HTTP verb using `.<span class="apidocCodeKeywordSpan">intercept</span>(path, verb [, requestBody [, options
]])`:

```js
scope('http://my.domain.com')
  .intercept('/path', 'PATCH')
  .reply(304);
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.interceptor" id="apidoc.element.nock.interceptor">
        function <span class="apidocSignatureSpan">nock.</span>interceptor
        <span class="apidocSignatureSpan">(scope, uri, method, requestBody, interceptorOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Interceptor(scope, uri, method, requestBody, interceptorOptions) {
    this.scope = scope;
    this.interceptorMatchHeaders = [];
    this.method = method.toUpperCase();
    this.uri = uri;
    this._key = this.method + ' ' + scope.basePath + scope.basePathname + (typeof uri === 'string' ? '' : '/') + uri;
    this.basePath = this.scope.basePath;
    this.path = (typeof uri === 'string') ? scope.basePathname + uri : uri;

    this.baseUri = this.method + ' ' + scope.basePath + scope.basePathname;
    this.options = interceptorOptions || {};
    this.counter = 1;
    this._requestBody = requestBody;

    //  We use lower-case header field names throughout Nock.
    this.reqheaders = common.headersFieldNamesToLowerCase((scope.scopeOptions &amp;&amp; scope.scopeOptions.reqheaders) || {});
    this.badheaders = common.headersFieldsArrayToLowerCase((scope.scopeOptions &amp;&amp; scope.scopeOptions.badheaders) || []);


    this.delayInMs = 0;
    this.delayConnectionInMs = 0;

    this.optional = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.isActive" id="apidoc.element.nock.isActive">
        function <span class="apidocSignatureSpan">nock.</span>isActive
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isActive() {

  //  If ClientRequest has been overwritten by Nock then originalClientRequest is not undefined.
  //  This means that Nock has been activated.
  return !_.isUndefined(originalClientRequest);

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.isDone" id="apidoc.element.nock.isDone">
        function <span class="apidocSignatureSpan">nock.</span>isDone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isDone() {
  return _.every(interceptorScopes(), function(scope) {
    return scope.isDone();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  * [Scope filtering](#scope-filtering)
  * [Path filtering](#path-filtering)
  * [Request Body filtering](#request-body-filtering)
  * [Request Headers Matching](#request-headers-matching)
  * [Optional Requests](#optional-requests)
  * [Allow __unmocked__ requests on a mocked hostname](#allow-__unmocked__-requests-on-a-mocked-hostname)
- [Expectations](#expectations)
  * [.<span class="apidocCodeKeywordSpan">isDone</span>()](#isdone)
  * [.cleanAll()](#cleanall)
  * [.persist()](#persist)
  * [.pendingMocks()](#pendingmocks)
  * [.activeMocks()](#activemocks)
- [Logging](#logging)
- [Restoring](#restoring)
- [Turning Nock Off (experimental!)](#turning-nock-off-experimental)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.load" id="apidoc.element.nock.load">
        function <span class="apidocSignatureSpan">nock.</span>load
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function load(path) {
  return define(loadDefs(path));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `path` - the path of the call (e.g. `'/pgte/nock'`)
* `body` - the body of the call, if any
* `status` - the HTTP status of the reply (e.g. `200`)
* `response` - the body of the reply which can be a JSON, string, hex string representing binary buffers or an array of such hex
 strings (when handling `content-encoded` in reply header)
* `headers` - the headers of the reply
* `reqheader` - the headers of the request

If you save this as a JSON file, you can load them directly through `nock.<span class="apidocCodeKeywordSpan">load</span>(path)`.
Then you can post-process them before using them in the tests for example to add them request body filtering (shown here fixing
timestamps to match the ones captured during recording):

```js
nocks = nock.load(pathToJson);
nocks.forEach(function(nock) {
nock.filteringRequestBody = function(body, aRecordedBody) {
  if (typeof(body) !== 'string' || typeof(aRecordedBody) !== 'string') {
    return body;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.loadDefs" id="apidoc.element.nock.loadDefs">
        function <span class="apidocSignatureSpan">nock.</span>loadDefs
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function loadDefs(path) {
  if (! fs) {
    throw new Error('No fs');
  }

  var contents = fs.readFileSync(path);
  return JSON.parse(contents);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return body.replace(/(timestamp):([0-9]+)/g, function(match, key, value) {
    return key + ':' + recordedTimestamp;
  });
};
});
```

Alternatively, if you need to pre-process the captured nock definitions before using them (e.g. to add scope filtering) then you
 can use `nock.<span class="apidocCodeKeywordSpan">loadDefs</span>(path)` and `nock.define(nockDefs)`. Shown here is scope filtering
 for Dropbox node module which constantly changes the subdomain to which it sends the requests:

```js
//  Pre-process the nock definitions as scope filtering has to be defined before the nocks are defined (due to its very hacky nature
).
var nockDefs = nock.loadDefs(pathToJson);
nockDefs.forEach(function(def) {
//  Do something with the definition object e.g. scope filtering.
def.options = def.options || {};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.pendingMocks" id="apidoc.element.nock.pendingMocks">
        function <span class="apidocSignatureSpan">nock.</span>pendingMocks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function pendingMocks() {
  return _.flatten(_.map(interceptorScopes(), function(scope) {
    return scope.pendingMocks();
  }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* 8.2.0
* Add changelog to the dev dependencies
* Ignore browserify-bundle.js
* Update browserify-bundle.js
* Merge pull request [#723](https://github.com/node-nock/nock/issues/723) from pimterry/optional-mocks
  Add optionally() and make isDone and pendingMocks consistent.
* Include all review markup changes in browserify-bundle
* Add .activeMocks() to recreate previous .<span class="apidocCodeKeywordSpan">pendingMocks</span>() behaviour
* Add times+optional and persist+optional tests
* Document assumption in pendingMocks()
* Clarify optional mock behaviour a little in README
* Merge pull request [#721](https://github.com/node-nock/nock/issues/721) from pimterry/removeInterceptor-from-pending
  Update PendingMocks when an interceptor is removed
* Merge pull request [#722](https://github.com/node-nock/nock/issues/722) from Ginden/no-garbage-in-npm
  Removed coverage folder from npm
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.removeInterceptor" id="apidoc.element.nock.removeInterceptor">
        function <span class="apidocSignatureSpan">nock.</span>removeInterceptor
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function removeInterceptor(options) {
  var baseUrl, key, method, proto;
  if (options instanceof Interceptor) {
    baseUrl = options.basePath;
    key = options._key;
  } else {
    proto = options.proto ? options.proto : 'http';

    common.normalizeRequestOptions(options);
    baseUrl = proto + '://' + options.host;
    method = options.method &amp;&amp; options.method.toUpperCase() || 'GET';
    key = method + ' ' + baseUrl + (options.path || '/');
  }

  if (allInterceptors[baseUrl] &amp;&amp; allInterceptors[baseUrl].scopes.length &gt; 0) {
    if (key) {
      for (var i = 0; i &lt; allInterceptors[baseUrl].scopes.length; i++) {
        var interceptor = allInterceptors[baseUrl].scopes[i];
        if (interceptor._key === key) {
          allInterceptors[baseUrl].scopes.splice(i, 1);
          interceptor.scope.remove(key, interceptor);
          break;
        }
      }
    } else {
      allInterceptors[baseUrl].scopes.length = 0;
    }

    return true;
  }

  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- [Enable/Disable real HTTP request](#enabledisable-real-http-request)
- [Recording](#recording)
* [`dont_print` option](#dont_print-option)
* [`output_objects` option](#output_objects-option)
* [`enable_reqheaders_recording` option](#enable_reqheaders_recording-option)
* [`logging` option](#logging-option)
* [`use_separator` option](#use_separator-option)
* [.<span class="apidocCodeKeywordSpan">removeInterceptor</span>()](#removeinterceptor)
- [Events](#events)
* [Global no match event](#global-no-match-event)
- [Nock Back](#nock-back)
* [Setup](#setup)
  + [Options](#options)
* [Usage](#usage)
  + [Options](#options-1)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.restore" id="apidoc.element.nock.restore">
        function <span class="apidocSignatureSpan">nock.</span>restore
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function restore() {
  debug(currentRecordingId, 'restoring all the overridden http/https properties');

  common.restoreOverriddenRequests();
  intercept.restoreOverriddenClientRequest();
  recordingInProgress = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

# Restoring

You can restore the HTTP interceptor to the normal unmocked behaviour by calling:

```js
nock.<span class="apidocCodeKeywordSpan">restore</span>();
```
**note**: restore does not clear the interceptor list. Use [nock.cleanAll()](#cleanall) if you expect the interceptor list to be
 empty.

# Turning Nock Off (experimental!)

You can bypass Nock completely by setting `NOCK_OFF` environment variable to `"true"`.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.scope" id="apidoc.element.nock.scope">
        function <span class="apidocSignatureSpan">nock.</span>scope
        <span class="apidocSignatureSpan">(basePath, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function startScope(basePath, options) {
  return new Scope(basePath, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.socket" id="apidoc.element.nock.socket">
        function <span class="apidocSignatureSpan">nock.</span>socket
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Socket(options) {
  if (!(this instanceof Socket)) {
    return new Socket(options);
  }

  EventEmitter.apply(this);

  options = options || {};

  if (options.proto === 'https') {
    this.authorized = true;
  }

  this.writable = true;
  this.readable = true;
  this.destroyed = false;

  this.setNoDelay = noop;
  this.setKeepAlive = noop;
  this.resume = noop;

  // totalDelay that has already been applied to the current
  // request/connection, timeout error will be generated if
  // it is timed-out.
  this.totalDelayMs = 0;
  // Maximum allowed delay. Null means unlimited.
  this.timeoutMs = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>














</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nock.back" id="apidoc.module.nock.back">module nock.back</a></h1>


    <h2>
        <a href="#apidoc.element.nock.back.back" id="apidoc.element.nock.back.back">
        function <span class="apidocSignatureSpan">nock.</span>back
        <span class="apidocSignatureSpan">(fixtureName, options, nockedFn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Back(fixtureName, options, nockedFn) {
  if(!Back.fixtures) {
    throw new Error(  'Back requires nock.back.fixtures to be set\n' +
                      'Ex:\n' +
                      '\trequire(nock).back.fixtures = \'/path/to/fixures/\'');
  }

  if( arguments.length === 2 ) {
    nockedFn = options;
    options = {};
  }

  _mode.setup();

  var fixture = path.join(Back.fixtures, fixtureName)
    , context = _mode.start(fixture, options);


  var nockDone = function () {
    _mode.finish(fixture, options, context);
  };

  debug('context:', context);

  nockedFn.call(context, nockDone);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.back.setMode" id="apidoc.element.nock.back.setMode">
        function <span class="apidocSignatureSpan">nock.back.</span>setMode
        <span class="apidocSignatureSpan">(mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setMode = function (mode) {
  if( !Modes.hasOwnProperty(mode) ) {
    throw new Error ('some usage error');
  }

  Back.currentMode = mode;
  debug('New nock back mode:', Back.currentMode);

  _mode = Modes[mode];
  _mode.setup();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

In your test helper

```javascript
var nockBack = require('nock').back;

nockBack.fixtures = '/path/to/fixtures/';
nockBack.<span class="apidocCodeKeywordSpan">setMode</span>('record');
```

### Options

- `nockBack.fixtures` : path to fixture directory
- `nockBack.setMode()` : the mode to use
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nock.common" id="apidoc.module.nock.common">module nock.common</a></h1>


    <h2>
        <a href="#apidoc.element.nock.common.contentEncoding" id="apidoc.element.nock.common.contentEncoding">
        function <span class="apidocSignatureSpan">nock.common.</span>contentEncoding
        <span class="apidocSignatureSpan">(headers, encoder)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function contentEncoding(headers, encoder) {
  var contentEncoding = _.get(headers, 'content-encoding');
  return contentEncoding === encoder;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
response.headers = _.extend({}, interceptor.headers);
response.rawHeaders = (interceptor.rawHeaders || []).slice();
debug('response.rawHeaders:', response.rawHeaders);


if (typeof interceptor.body === 'function') {
  if (requestBody &amp;&amp; common.isJSONContent(options.headers)) {
    if (requestBody &amp;&amp; common.<span class="apidocCodeKeywordSpan">contentEncoding</span>(options.headers, 'gzip&amp;#
x27;)) {
      if (typeof zlib.gunzipSync !== 'function') {
        emitError(new Error('Gzip encoding is currently not supported in this version of Node.'));
        return;
      }
      requestBody = String(zlib.gunzipSync(new Buffer(requestBody, 'hex')), 'hex')
    } else if (requestBody &amp;&amp; common.contentEncoding(options.headers, 'deflate')) {
      if (typeof zlib.deflateSync !== 'function') {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.common.deleteHeadersField" id="apidoc.element.nock.common.deleteHeadersField">
        function <span class="apidocSignatureSpan">nock.common.</span>deleteHeadersField
        <span class="apidocSignatureSpan">(headers, fieldNameToDelete)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deleteHeadersField = function (headers, fieldNameToDelete) {

  if(!_.isObject(headers) || !_.isString(fieldNameToDelete)) {
    return;
  }

  var lowerCaseFieldNameToDelete = fieldNameToDelete.toLowerCase();

  //  Search through the headers and delete all values whose field name matches the given field name.
  _(headers).keys().each(function(fieldName) {
    var lowerCaseFieldName = fieldName.toLowerCase();
    if(lowerCaseFieldName === lowerCaseFieldNameToDelete) {
      delete headers[fieldName];
      //  We don't stop here but continue in order to remove *all* matching field names
      //  (even though if seen regorously there shouldn't be any)
    }
  });

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var out;
if(output_objects) {
  out = generateRequestAndResponseObject(req, bodyChunks, options, res, dataChunks);
  if(out.reqheaders) {
    //  We never record user-agent headers as they are worse than useless -
    //  they actually make testing more difficult without providing any benefit (see README)
    common.<span class="apidocCodeKeywordSpan">deleteHeadersField</span>(out.reqheaders, 'user-agent');

    //  Remove request headers completely unless it was explicitly enabled by the user (see README)
    if(!enable_reqheaders_recording) {
      delete out.reqheaders;
    }
  }
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.common.formatQueryValue" id="apidoc.element.nock.common.formatQueryValue">
        function <span class="apidocSignatureSpan">nock.common.</span>formatQueryValue
        <span class="apidocSignatureSpan">(key, value, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function formatQueryValue(key, value, options) {
  switch (true) {
    case _.isNumber(value): // fall-though
    case _.isBoolean(value):
      value = value.toString();
      break;
    case _.isUndefined(value): // fall-though
    case _.isNull(value):
      value = '';
      break;
    case _.isString(value):
      if(options.encodedQueryParams) {
        value = percentDecode(value);
      }
      break;
    case (value instanceof RegExp):
      break;
    case _.isArray(value):
      var tmpArray = new Array(value.length);
      for (var i = 0; i &lt; value.length; ++i) {
        tmpArray[i] = formatQueryValue(i, value[i], options)[1];
      }
      value = tmpArray;
      break;
    case _.isObject(value):
      var tmpObj = {};
      _.forOwn(value, function(subVal, subKey){
        var subPair = formatQueryValue(subKey, subVal, options);
        tmpObj[subPair[0]] = subPair[1];
      });
      value = tmpObj;
      break;
  }

  if (options.encodedQueryParams) key = percentDecode(key);
  return [key, value];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        this.queries = queries;
        return this;
    }

    for (var q in queries) {
        if (_.isUndefined(this.queries[q])) {
            var value = queries[q];
            var formatedPair = common.<span class="apidocCodeKeywordSpan">formatQueryValue</span>(q, value, this.scope.scopeOptions
);
            this.queries[formatedPair[0]] = formatedPair[1];
        }
    }

    return this;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.common.headersArrayToObject" id="apidoc.element.nock.common.headersArrayToObject">
        function <span class="apidocSignatureSpan">nock.common.</span>headersArrayToObject
        <span class="apidocSignatureSpan">(rawHeaders)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">headersArrayToObject = function (rawHeaders) {
  if(!_.isArray(rawHeaders)) {
    return rawHeaders;
  }

  var headers = {};

  for (var i=0, len=rawHeaders.length; i&lt;len; i=i+2) {
    var key = rawHeaders[i];
    var value = rawHeaders[i+1];

    if (headers[key]) {
      headers[key] = _.isArray(headers[key]) ? headers[key] : [headers[key]];
      headers[key].push(value);
    } else {
      headers[key] = value;
    }
  }

  return headers;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

this.statusCode = statusCode;

_.defaults(this.options, this.scope.scopeOptions);

// convert rawHeaders from Array to Object
var headers = common.<span class="apidocCodeKeywordSpan">headersArrayToObject</span>(rawHeaders);

if (this.scope._defaultReplyHeaders) {
    headers = headers || {};
    headers = mixin(this.scope._defaultReplyHeaders, headers);
}

if (this.scope.date) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.common.headersFieldNamesToLowerCase" id="apidoc.element.nock.common.headersFieldNamesToLowerCase">
        function <span class="apidocSignatureSpan">nock.common.</span>headersFieldNamesToLowerCase
        <span class="apidocSignatureSpan">(headers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">headersFieldNamesToLowerCase = function (headers) {
  if(!_.isObject(headers)) {
    return headers;
  }

  //  For each key in the headers, delete its value and reinsert it with lower-case key.
  //  Keys represent headers field names.
  var lowerCaseHeaders = {};
  _.forOwn(headers, function(fieldVal, fieldName) {
    var lowerCaseFieldName = fieldName.toLowerCase();
    if(!_.isUndefined(lowerCaseHeaders[lowerCaseFieldName])) {
      throw new Error('Failed to convert header keys to lower case due to field name conflict: ' + lowerCaseFieldName);
    }
    lowerCaseHeaders[lowerCaseFieldName] = fieldVal;
  });

  return lowerCaseHeaders;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

this.baseUri = this.method + ' ' + scope.basePath + scope.basePathname;
this.options = interceptorOptions || {};
this.counter = 1;
this._requestBody = requestBody;

//  We use lower-case header field names throughout Nock.
this.reqheaders = common.<span class="apidocCodeKeywordSpan">headersFieldNamesToLowerCase</span>((scope.scopeOptions &amp;&amp;
; scope.scopeOptions.reqheaders) || {});
this.badheaders = common.headersFieldsArrayToLowerCase((scope.scopeOptions &amp;&amp; scope.scopeOptions.badheaders) || []);


this.delayInMs = 0;
this.delayConnectionInMs = 0;

this.optional = false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.common.headersFieldsArrayToLowerCase" id="apidoc.element.nock.common.headersFieldsArrayToLowerCase">
        function <span class="apidocSignatureSpan">nock.common.</span>headersFieldsArrayToLowerCase
        <span class="apidocSignatureSpan">(headers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">headersFieldsArrayToLowerCase = function (headers) {
  return _.uniq(_.map(headers, function (fieldName) {
    return fieldName.toLowerCase();
  }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.baseUri = this.method + ' ' + scope.basePath + scope.basePathname;
    this.options = interceptorOptions || {};
    this.counter = 1;
    this._requestBody = requestBody;

    //  We use lower-case header field names throughout Nock.
    this.reqheaders = common.headersFieldNamesToLowerCase((scope.scopeOptions &amp;&amp; scope.scopeOptions.reqheaders) || {});
    this.badheaders = common.<span class="apidocCodeKeywordSpan">headersFieldsArrayToLowerCase</span>((scope.scopeOptions &amp;&amp;#
x26; scope.scopeOptions.badheaders) || []);


    this.delayInMs = 0;
    this.delayConnectionInMs = 0;

    this.optional = false;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.common.isBinaryBuffer" id="apidoc.element.nock.common.isBinaryBuffer">
        function <span class="apidocSignatureSpan">nock.common.</span>isBinaryBuffer
        <span class="apidocSignatureSpan">(buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isBinaryBuffer = function (buffer) {

  if(!Buffer.isBuffer(buffer)) {
    return false;
  }

  //  Test if the buffer can be reconstructed verbatim from its utf8 encoding.
  var utfEncodedBuffer = buffer.toString('utf8');
  var reconstructedBuffer = new Buffer(utfEncodedBuffer, 'utf8');
  var compareBuffers = function(lhs, rhs) {
    if(lhs.length !== rhs.length) {
      return false;
    }

    for(var i = 0; i &lt; lhs.length; ++i) {
      if(lhs[i] !== rhs[i]) {
        return false;
      }
    }

    return true;
  };

  //  If the buffers are *not* equal then this is a "binary buffer"
  //  meaning that it cannot be faitfully represented in utf8.
  return !compareBuffers(buffer, reconstructedBuffer);

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var mergedBuffer = common.mergeChunks(chunks);

//  The merged buffer can be one of three things:
//    1.  A binary buffer which then has to be recorded as a hex string.
//    2.  A string buffer which represents a JSON object.
//    3.  A string buffer which doesn't represent a JSON object.

if(common.<span class="apidocCodeKeywordSpan">isBinaryBuffer</span>(mergedBuffer)) {
  return mergedBuffer.toString('hex');
} else {
  var maybeStringifiedJson = mergedBuffer.toString('utf8');
  try {
    return JSON.parse(maybeStringifiedJson);
  } catch(err) {
    return maybeStringifiedJson;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.common.isContentEncoded" id="apidoc.element.nock.common.isContentEncoded">
        function <span class="apidocSignatureSpan">nock.common.</span>isContentEncoded
        <span class="apidocSignatureSpan">(headers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isContentEncoded(headers) {
  var contentEncoding = _.get(headers, 'content-encoding');
  return _.isString(contentEncoding) &amp;&amp; contentEncoding !== '';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    debug('reply.headers:', this.headers);
    debug('reply.rawHeaders:', this.rawHeaders);
}

//  If the content is not encoded we may need to transform the response body.
//  Otherwise we leave it as it is.
if (!common.<span class="apidocCodeKeywordSpan">isContentEncoded</span>(this.headers)) {
    if (body &amp;&amp; typeof(body) !== 'string' &amp;&amp;
        typeof(body) !== 'function' &amp;&amp;
        !Buffer.isBuffer(body) &amp;&amp;
        !common.isStream(body)) {
        try {
            body = stringify(body);
            if (!this.headers) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.common.isJSONContent" id="apidoc.element.nock.common.isJSONContent">
        function <span class="apidocSignatureSpan">nock.common.</span>isJSONContent
        <span class="apidocSignatureSpan">(headers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isJSONContent(headers) {
  var contentType = _.get(headers, 'content-type');
  if (Array.isArray(contentType)) {
    contentType = contentType[0];
  }
  contentType = (contentType || '').toLocaleLowerCase();

  return contentType === 'application/json';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Clone headers/rawHeaders to not override them when evaluating later
response.headers = _.extend({}, interceptor.headers);
response.rawHeaders = (interceptor.rawHeaders || []).slice();
debug('response.rawHeaders:', response.rawHeaders);


if (typeof interceptor.body === 'function') {
  if (requestBody &amp;&amp; common.<span class="apidocCodeKeywordSpan">isJSONContent</span>(options.headers)) {
    if (requestBody &amp;&amp; common.contentEncoding(options.headers, 'gzip')) {
      if (typeof zlib.gunzipSync !== 'function') {
        emitError(new Error('Gzip encoding is currently not supported in this version of Node.'));
        return;
      }
      requestBody = String(zlib.gunzipSync(new Buffer(requestBody, 'hex')), 'hex')
    } else if (requestBody &amp;&amp; common.contentEncoding(options.headers, 'deflate')) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.common.isStream" id="apidoc.element.nock.common.isStream">
        function <span class="apidocSignatureSpan">nock.common.</span>isStream
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isStream(obj) {
  return obj &amp;&amp;
      (typeof a !== 'string') &amp;&amp;
      (! Buffer.isBuffer(obj)) &amp;&amp;
      _.isFunction(obj.setEncoding);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function DelayedBody(ms, body) {
  Transform.call(this);

  var self = this;
  var data = '';
  var ended = false;

  if (common.<span class="apidocCodeKeywordSpan">isStream</span>(body)) {
body.on('data', function (chunk) {
  data += Buffer.isBuffer(chunk) ? chunk.toString() : chunk;
});

body.once('end', function () {
  ended = true;
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.common.matchStringOrRegexp" id="apidoc.element.nock.common.matchStringOrRegexp">
        function <span class="apidocSignatureSpan">nock.common.</span>matchStringOrRegexp
        <span class="apidocSignatureSpan">(target, pattern)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function matchStringOrRegexp(target, pattern) {
  var str = target &amp;&amp; target.toString ? target.toString() : target;

  return pattern instanceof RegExp  ? str.match(pattern) : str === pattern;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    scope.__nock_filteredScope = scope.__nock_scopeKey;
    matchingInterceptor = interceptor.scopes;
    //  Break out of _.each for scopes.
    return false;
  }
});

if (!matchingInterceptor &amp;&amp; common.<span class="apidocCodeKeywordSpan">matchStringOrRegexp</span>(basePath, interceptor
.key)) {
  matchingInterceptor = interceptor.scopes;
  // false to short circuit the .each
  return false;
}

//  Returning falsy value here (which will happen if we have found our matching interceptor)
//  will break out of _.each for all interceptors.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.common.mergeChunks" id="apidoc.element.nock.common.mergeChunks">
        function <span class="apidocSignatureSpan">nock.common.</span>mergeChunks
        <span class="apidocSignatureSpan">(chunks)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mergeChunks = function (chunks) {

  if(_.isEmpty(chunks)) {
    return new Buffer(0);
  }

  //  We assume that all chunks are Buffer objects if the first is buffer object.
  var areBuffers = Buffer.isBuffer(_.first(chunks));

  if(!areBuffers) {
    //  When the chunks are not buffers we assume that they are strings.
    return chunks.join('');
  }

  //  Merge all the buffers into a single Buffer object.
  return Buffer.concat(chunks);

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
    }

    return chunk.toString('hex');
  });
}

var mergedBuffer = common.<span class="apidocCodeKeywordSpan">mergeChunks</span>(chunks);

//  The merged buffer can be one of three things:
//    1.  A binary buffer which then has to be recorded as a hex string.
//    2.  A string buffer which represents a JSON object.
//    3.  A string buffer which doesn't represent a JSON object.

if(common.isBinaryBuffer(mergedBuffer)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.common.normalizeRequestOptions" id="apidoc.element.nock.common.normalizeRequestOptions">
        function <span class="apidocSignatureSpan">nock.common.</span>normalizeRequestOptions
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">normalizeRequestOptions = function (options) {
  options.proto = options.proto || (options._https_ ? 'https': 'http');
  options.port = options.port || ((options.proto === 'http') ? 80 : 443);
  if (options.host) {
    debug('options.host:', options.host);
    if (! options.hostname) {
      if (options.host.split(':').length == 2) {
        options.hostname = options.host.split(':')[0];
      } else {
        options.hostname = options.host;
      }
    }
  }
  debug('options.hostname in the end: %j', options.hostname);
  options.host = (options.hostname || 'localhost') + ':' + options.port;
  debug('options.host in the end: %j', options.host);

  /// lowercase host names
  ['hostname', 'host'].forEach(function(attr) {
    if (options[attr]) {
      options[attr] = options[attr].toLowerCase();
    }
  });

  return options;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    allowNetConnect = matcher;
  } else {
    allowNetConnect = /.*/;
  }
}

function isEnabledForNetConnect(options) {
  common.<span class="apidocCodeKeywordSpan">normalizeRequestOptions</span>(options);

  var enabled = allowNetConnect &amp;&amp; allowNetConnect.test(options.host);
  debug('Net connect', enabled ? '' : 'not', 'enabled for', options.host);
  return enabled;
}

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.common.overrideRequests" id="apidoc.element.nock.common.overrideRequests">
        function <span class="apidocSignatureSpan">nock.common.</span>overrideRequests
        <span class="apidocSignatureSpan">(newRequest)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">overrideRequests = function (newRequest) {
  debug('overriding requests');

  ['http', 'https'].forEach(function(proto) {
    debug('- overriding request for', proto);

    var moduleName = proto, // 1 to 1 match of protocol and module is fortunate :)
        module = {
          http: require('http'),
          https: require('https')
        }[moduleName],
        overriddenRequest = module.request;

    if(requestOverride[moduleName]) {
      throw new Error('Module\'s request already overridden for ' + moduleName + ' protocol.');
    }

    //  Store the properties of the overridden request so that it can be restored later on.
    requestOverride[moduleName] = {
      module: module,
      request: overriddenRequest
    };

    module.request = function(options, callback) {
      // debug('request options:', options);
      return newRequest(proto, overriddenRequest.bind(module), options, callback);
    };

    debug('- overridden request for', proto);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
throw new Error('Nock already active');
  }

  overrideClientRequest();

  // ----- Overriding http.request and https.request:

  common.<span class="apidocCodeKeywordSpan">overrideRequests</span>(function(proto, overriddenRequest, options, callback) {
//  NOTE: overriddenRequest is already bound to its module.
var req,
    res;

if (typeof options === 'string') {
  options = parse(options);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.common.percentDecode" id="apidoc.element.nock.common.percentDecode">
        function <span class="apidocSignatureSpan">nock.common.</span>percentDecode
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function percentDecode(str) {
  try {
    return decodeURIComponent(str.replace(/\+/g, ' '));
  } catch (e) {
    return str;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.common.percentEncode" id="apidoc.element.nock.common.percentEncode">
        function <span class="apidocSignatureSpan">nock.common.</span>percentEncode
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function percentEncode(str) {
  return encodeURIComponent(str).replace(/[!'()*]/g, function(c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.common.restoreOverriddenRequests" id="apidoc.element.nock.common.restoreOverriddenRequests">
        function <span class="apidocSignatureSpan">nock.common.</span>restoreOverriddenRequests
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">restoreOverriddenRequests = function () {
  debug('restoring requests');

  //  Restore any overridden requests.
  _(requestOverride).keys().each(function(proto) {
    debug('- restoring request for', proto);

    var override = requestOverride[proto];
    if(override) {
      override.module.request = override.request;
      debug('- restored request for', proto);
    }
  });
  requestOverride = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  debug(thisRecordingId, 'restoring overridden requests before new overrides');
  //  To preserve backward compatibility (starting recording wasn't throwing if nock was already active)
  //  we restore any requests that may have been overridden by other parts of nock (e.g. intercept)
  //  NOTE: This is hacky as hell but it keeps the backward compatibility *and* allows correct
  //    behavior in the face of other modules also overriding ClientRequest.
  common.<span class="apidocCodeKeywordSpan">restoreOverriddenRequests</span>();
  //  We restore ClientRequest as it messes with recording of modules that also override ClientRequest (e.g. xhr2)
  intercept.restoreOverriddenClientRequest();

  //  We override the requests so that we can save information on them before executing.
  common.overrideRequests(function(proto, overriddenRequest, options, callback) {

var bodyChunks = [];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.common.stringifyRequest" id="apidoc.element.nock.common.stringifyRequest">
        function <span class="apidocSignatureSpan">nock.common.</span>stringifyRequest
        <span class="apidocSignatureSpan">(options, body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function stringifyRequest(options, body) {
  var method = options.method || 'GET';

  var port = options.port;
  if (! port) port = (options.proto == 'https' ? '443' : '80');

  if (options.proto == 'https' &amp;&amp; port == '443' ||
      options.proto == 'http' &amp;&amp; port == '80') {
    port = '';
  }

  if (port) port = ':' + port;

  var log = {
    method: method,
    url: options.proto + '://' + options.hostname + port + options.path,
    headers: options.headers
  };

  if (body) {
    log.body = body;
  }

  return JSON.stringify(log, null, 2);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      propagate(newReq, req);
      //  We send the raw buffer as we received it, not as we interpreted it.
      newReq.end(requestBodyBuffer);
      return;
    }
  }

  var err = new Error("Nock: No match for request " + common.<span class="apidocCodeKeywordSpan">stringifyRequest</span>(options, requestBody));
  err.statusCode = err.status = 404;
  emitError(err);
  return;
}

debug('interceptor identified, starting mocking');
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nock.delayed_body" id="apidoc.module.nock.delayed_body">module nock.delayed_body</a></h1>


    <h2>
        <a href="#apidoc.element.nock.delayed_body.delayed_body" id="apidoc.element.nock.delayed_body.delayed_body">
        function <span class="apidocSignatureSpan">nock.</span>delayed_body
        <span class="apidocSignatureSpan">(ms, body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DelayedBody(ms, body) {
  Transform.call(this);

  var self = this;
  var data = '';
  var ended = false;

  if (common.isStream(body)) {
    body.on('data', function (chunk) {
      data += Buffer.isBuffer(chunk) ? chunk.toString() : chunk;
    });

    body.once('end', function () {
      ended = true;
    });

    body.resume();
  }

  setTimeout(function () {
    if (common.isStream(body) &amp;&amp; !ended) {
      body.once('end', function () {
        self.end(data);
      });
    } else {
      self.end(data || body);
    }
  }, ms);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.delayed_body.super_" id="apidoc.element.nock.delayed_body.super_">
        function <span class="apidocSignatureSpan">nock.delayed_body.</span>super_
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(this);

  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function')
      this._transform = options.transform;

    if (typeof options.flush === 'function')
      this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.once('prefinish', function() {
    if (typeof this._flush === 'function')
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nock.delayed_body.prototype" id="apidoc.module.nock.delayed_body.prototype">module nock.delayed_body.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.nock.delayed_body.prototype._transform" id="apidoc.element.nock.delayed_body.prototype._transform">
        function <span class="apidocSignatureSpan">nock.delayed_body.prototype.</span>_transform
        <span class="apidocSignatureSpan">(chunk, encoding, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_transform = function (chunk, encoding, cb) {
  this.push(chunk);
  process.nextTick(cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nock.intercept" id="apidoc.module.nock.intercept">module nock.intercept</a></h1>


    <h2>
        <a href="#apidoc.element.nock.intercept.intercept" id="apidoc.element.nock.intercept.intercept">
        function <span class="apidocSignatureSpan">nock.</span>intercept
        <span class="apidocSignatureSpan">(key, interceptor, scope, scopeOptions, host)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function add(key, interceptor, scope, scopeOptions, host) {
  if (! allInterceptors.hasOwnProperty(key)) {
    allInterceptors[key] = { key: key, scopes: [] };
  }
  interceptor.__nock_scope = scope;

  //  We need scope's key and scope options for scope filtering function (if defined)
  interceptor.__nock_scopeKey = key;
  interceptor.__nock_scopeOptions = scopeOptions;
  //  We need scope's host for setting correct request headers for filtered scopes.
  interceptor.__nock_scopeHost = host;
  interceptor.interceptionCounter = 0;

  allInterceptors[key].scopes.push(interceptor);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  .reply(200, { hello: 'world' });
```

## HTTP Verbs

Nock supports any HTTP verb, and it has convenience methods for the GET, POST, PUT, HEAD, DELETE, PATCH and MERGE HTTP verbs.

You can intercept any HTTP verb using `.<span class="apidocCodeKeywordSpan">intercept</span>(path, verb [, requestBody [, options
]])`:

```js
scope('http://my.domain.com')
  .intercept('/path', 'PATCH')
  .reply(304);
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.intercept.activate" id="apidoc.element.nock.intercept.activate">
        function <span class="apidocSignatureSpan">nock.intercept.</span>activate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function activate() {

  if(originalClientRequest) {
    throw new Error('Nock already active');
  }

  overrideClientRequest();

  // ----- Overriding http.request and https.request:

  common.overrideRequests(function(proto, overriddenRequest, options, callback) {
    //  NOTE: overriddenRequest is already bound to its module.
    var req,
        res;

    if (typeof options === 'string') {
      options = parse(options);
    }
    options.proto = proto;

    var interceptors = interceptorsFor(options)

    if (isOn() &amp;&amp; interceptors) {
      var matches = false,
          allowUnmocked = false;

      matches = !! _.find(interceptors, function(interceptor) {
        return interceptor.matchIndependentOfBody(options);
      });

      allowUnmocked = !! _.find(interceptors, function(interceptor) {
        return interceptor.options.allowUnmocked;
      });

      if (! matches &amp;&amp; allowUnmocked) {
        if (proto === 'https') {
          var ClientRequest = http.ClientRequest;
          http.ClientRequest = originalClientRequest;
          req = overriddenRequest(options, callback);
          http.ClientRequest = ClientRequest;
        } else {
          req = overriddenRequest(options, callback);
        }
        globalEmitter.emit('no match', req);
        return req;
      }

      //  NOTE: Since we already overrode the http.ClientRequest we are in fact constructing
      //    our own OverriddenClientRequest.
      req = new http.ClientRequest(options);

      res = RequestOverrider(req, options, interceptors, remove);
      if (callback) {
        res.on('response', callback);
      }
      return req;
    } else {
      globalEmitter.emit('no match', options);
      if (isOff() || isEnabledForNetConnect(options)) {
        return overriddenRequest(options, callback);
      } else {
        var error = new NetConnectNotAllowedError(options.host, options.path);
        return new ErroringClientRequest(error);
      }
    }
  });

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var wild = {


setup: function () {
  nock.cleanAll();
  recorder.restore();
  nock.<span class="apidocCodeKeywordSpan">activate</span>();
  nock.enableNetConnect();
},


start: function () {
  return load(); //don't load anything but get correct context
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.intercept.activeMocks" id="apidoc.element.nock.intercept.activeMocks">
        function <span class="apidocSignatureSpan">nock.intercept.</span>activeMocks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function activeMocks() {
  return _.flatten(_.map(interceptorScopes(), function(scope) {
    return scope.activeMocks();
  }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* 8.2.0
* Add changelog to the dev dependencies
* Ignore browserify-bundle.js
* Update browserify-bundle.js
* Merge pull request [#723](https://github.com/node-nock/nock/issues/723) from pimterry/optional-mocks
  Add optionally() and make isDone and pendingMocks consistent.
* Include all review markup changes in browserify-bundle
* Add .<span class="apidocCodeKeywordSpan">activeMocks</span>() to recreate previous .pendingMocks() behaviour
* Add times+optional and persist+optional tests
* Document assumption in pendingMocks()
* Clarify optional mock behaviour a little in README
* Merge pull request [#721](https://github.com/node-nock/nock/issues/721) from pimterry/removeInterceptor-from-pending
  Update PendingMocks when an interceptor is removed
* Merge pull request [#722](https://github.com/node-nock/nock/issues/722) from Ginden/no-garbage-in-npm
  Removed coverage folder from npm
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.intercept.disableNetConnect" id="apidoc.element.nock.intercept.disableNetConnect">
        function <span class="apidocSignatureSpan">nock.intercept.</span>disableNetConnect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function disableNetConnect() {
  allowNetConnect = undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
# Enable/Disable real HTTP request

As default, if you do not mock a host, a real HTTP request will do, but sometimes you should not permit real HTTP request, so...

For disabling real http requests.

```js
nock.<span class="apidocCodeKeywordSpan">disableNetConnect</span>();
```

So, if you try to request any host not 'nocked', it will thrown an `NetConnectNotAllowedError`.

```js
nock.disableNetConnect();
var req = http.get('http://google.com/');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.intercept.enableNetConnect" id="apidoc.element.nock.intercept.enableNetConnect">
        function <span class="apidocSignatureSpan">nock.intercept.</span>enableNetConnect
        <span class="apidocSignatureSpan">(matcher)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function enableNetConnect(matcher) {
  if (_.isString(matcher)) {
    allowNetConnect = new RegExp(matcher);
  } else if (_.isObject(matcher) &amp;&amp; _.isFunction(matcher.test)) {
    allowNetConnect = matcher;
  } else {
    allowNetConnect = /.*/;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// This code will log a NetConnectNotAllowedError with message:
// Nock: Not allow net connect for "google.com:80"
```

For enabling real HTTP requests (the default behaviour).

```js
nock.<span class="apidocCodeKeywordSpan">enableNetConnect</span>();
```

You could allow real HTTP request for certain host names by providing a string or a regular expression for the hostname:

```js
// using a string
nock.enableNetConnect('amazon.com');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.intercept.isActive" id="apidoc.element.nock.intercept.isActive">
        function <span class="apidocSignatureSpan">nock.intercept.</span>isActive
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isActive() {

  //  If ClientRequest has been overwritten by Nock then originalClientRequest is not undefined.
  //  This means that Nock has been activated.
  return !_.isUndefined(originalClientRequest);

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.intercept.isDone" id="apidoc.element.nock.intercept.isDone">
        function <span class="apidocSignatureSpan">nock.intercept.</span>isDone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isDone() {
  return _.every(interceptorScopes(), function(scope) {
    return scope.isDone();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  * [Scope filtering](#scope-filtering)
  * [Path filtering](#path-filtering)
  * [Request Body filtering](#request-body-filtering)
  * [Request Headers Matching](#request-headers-matching)
  * [Optional Requests](#optional-requests)
  * [Allow __unmocked__ requests on a mocked hostname](#allow-__unmocked__-requests-on-a-mocked-hostname)
- [Expectations](#expectations)
  * [.<span class="apidocCodeKeywordSpan">isDone</span>()](#isdone)
  * [.cleanAll()](#cleanall)
  * [.persist()](#persist)
  * [.pendingMocks()](#pendingmocks)
  * [.activeMocks()](#activemocks)
- [Logging](#logging)
- [Restoring](#restoring)
- [Turning Nock Off (experimental!)](#turning-nock-off-experimental)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.intercept.isOn" id="apidoc.element.nock.intercept.isOn">
        function <span class="apidocSignatureSpan">nock.intercept.</span>isOn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isOn() {
  return !isOff();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Scope.prototype.activeMocks = function activeMocks() {
  return Object.keys(this.keyedInterceptors);
}

Scope.prototype.isDone = function isDone() {
  var self = this;
  // if nock is turned off, it always says it's done
  if (! globalIntercept.<span class="apidocCodeKeywordSpan">isOn</span>()) { return true; }

  return this.pendingMocks().length === 0;
};

Scope.prototype.done = function done() {
  assert.ok(this.isDone(), "Mocks not yet satisfied:\n" + this.pendingMocks().join("\n"));
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.intercept.overrideClientRequest" id="apidoc.element.nock.intercept.overrideClientRequest">
        function <span class="apidocSignatureSpan">nock.intercept.</span>overrideClientRequest
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function overrideClientRequest() {
  debug('Overriding ClientRequest');

  if(originalClientRequest) {
    throw new Error('Nock already overrode http.ClientRequest');
  }

  // ----- Extending http.ClientRequest

  //  Define the overriding client request that nock uses internally.
  function OverriddenClientRequest(options, cb) {
    if (http.OutgoingMessage) http.OutgoingMessage.call(this);

    //  Filter the interceptors per request options.
    var interceptors = interceptorsFor(options);

    if (isOn() &amp;&amp; interceptors) {
      debug('using', interceptors.length, 'interceptors');

      //  Use filtered interceptors to intercept requests.
      var overrider = RequestOverrider(this, options, interceptors, remove, cb);
      for(var propName in overrider) {
        if (overrider.hasOwnProperty(propName)) {
          this[propName] = overrider[propName];
        }
      }
    } else {
      debug('falling back to original ClientRequest');

      //  Fallback to original ClientRequest if nock is off or the net connection is enabled.
      if(isOff() || isEnabledForNetConnect(options)) {
        originalClientRequest.apply(this, arguments);
      } else {
        timers.setImmediate(function () {
          var error = new NetConnectNotAllowedError(options.host, options.path);
          this.emit('error', error);
        }.bind(this));
      }
    }
  }
  if (http.ClientRequest) {
    inherits(OverriddenClientRequest, http.ClientRequest);
  } else {
    inherits(OverriddenClientRequest, EventEmitter);
  }

  //  Override the http module's request but keep the original so that we can use it and later restore it.
  //  NOTE: We only override http.ClientRequest as https module also uses it.
  originalClientRequest = http.ClientRequest;
  http.ClientRequest = OverriddenClientRequest;

  debug('ClientRequest overridden');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.intercept.pendingMocks" id="apidoc.element.nock.intercept.pendingMocks">
        function <span class="apidocSignatureSpan">nock.intercept.</span>pendingMocks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function pendingMocks() {
  return _.flatten(_.map(interceptorScopes(), function(scope) {
    return scope.pendingMocks();
  }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* 8.2.0
* Add changelog to the dev dependencies
* Ignore browserify-bundle.js
* Update browserify-bundle.js
* Merge pull request [#723](https://github.com/node-nock/nock/issues/723) from pimterry/optional-mocks
  Add optionally() and make isDone and pendingMocks consistent.
* Include all review markup changes in browserify-bundle
* Add .activeMocks() to recreate previous .<span class="apidocCodeKeywordSpan">pendingMocks</span>() behaviour
* Add times+optional and persist+optional tests
* Document assumption in pendingMocks()
* Clarify optional mock behaviour a little in README
* Merge pull request [#721](https://github.com/node-nock/nock/issues/721) from pimterry/removeInterceptor-from-pending
  Update PendingMocks when an interceptor is removed
* Merge pull request [#722](https://github.com/node-nock/nock/issues/722) from Ginden/no-garbage-in-npm
  Removed coverage folder from npm
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.intercept.removeAll" id="apidoc.element.nock.intercept.removeAll">
        function <span class="apidocSignatureSpan">nock.intercept.</span>removeAll
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function removeAll() {
  Object.keys(allInterceptors).forEach(function(key) {
    allInterceptors[key].scopes.forEach(function(interceptor) {
      interceptor.scope.keyedInterceptors = {};
    });
  });
  allInterceptors = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return this;
};




function cleanAll() {
globalIntercept.<span class="apidocCodeKeywordSpan">removeAll</span>();
return module.exports;
}

function loadDefs(path) {
if (! fs) {
  throw new Error('No fs');
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.intercept.removeInterceptor" id="apidoc.element.nock.intercept.removeInterceptor">
        function <span class="apidocSignatureSpan">nock.intercept.</span>removeInterceptor
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function removeInterceptor(options) {
  var baseUrl, key, method, proto;
  if (options instanceof Interceptor) {
    baseUrl = options.basePath;
    key = options._key;
  } else {
    proto = options.proto ? options.proto : 'http';

    common.normalizeRequestOptions(options);
    baseUrl = proto + '://' + options.host;
    method = options.method &amp;&amp; options.method.toUpperCase() || 'GET';
    key = method + ' ' + baseUrl + (options.path || '/');
  }

  if (allInterceptors[baseUrl] &amp;&amp; allInterceptors[baseUrl].scopes.length &gt; 0) {
    if (key) {
      for (var i = 0; i &lt; allInterceptors[baseUrl].scopes.length; i++) {
        var interceptor = allInterceptors[baseUrl].scopes[i];
        if (interceptor._key === key) {
          allInterceptors[baseUrl].scopes.splice(i, 1);
          interceptor.scope.remove(key, interceptor);
          break;
        }
      }
    } else {
      allInterceptors[baseUrl].scopes.length = 0;
    }

    return true;
  }

  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- [Enable/Disable real HTTP request](#enabledisable-real-http-request)
- [Recording](#recording)
* [`dont_print` option](#dont_print-option)
* [`output_objects` option](#output_objects-option)
* [`enable_reqheaders_recording` option](#enable_reqheaders_recording-option)
* [`logging` option](#logging-option)
* [`use_separator` option](#use_separator-option)
* [.<span class="apidocCodeKeywordSpan">removeInterceptor</span>()](#removeinterceptor)
- [Events](#events)
* [Global no match event](#global-no-match-event)
- [Nock Back](#nock-back)
* [Setup](#setup)
  + [Options](#options)
* [Usage](#usage)
  + [Options](#options-1)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.intercept.restoreOverriddenClientRequest" id="apidoc.element.nock.intercept.restoreOverriddenClientRequest">
        function <span class="apidocSignatureSpan">nock.intercept.</span>restoreOverriddenClientRequest
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function restoreOverriddenClientRequest() {
  debug('restoring overriden ClientRequest');

  //  Restore the ClientRequest we have overridden.
  if(!originalClientRequest) {
    debug('- ClientRequest was not overridden');
  } else {
    http.ClientRequest = originalClientRequest;
    originalClientRequest = undefined;

    debug('- ClientRequest restored');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  debug(thisRecordingId, 'restoring overridden requests before new overrides');
  //  To preserve backward compatibility (starting recording wasn't throwing if nock was already active)
  //  we restore any requests that may have been overridden by other parts of nock (e.g. intercept)
  //  NOTE: This is hacky as hell but it keeps the backward compatibility *and* allows correct
  //    behavior in the face of other modules also overriding ClientRequest.
  common.restoreOverriddenRequests();
  //  We restore ClientRequest as it messes with recording of modules that also override ClientRequest (e.g. xhr2)
  intercept.<span class="apidocCodeKeywordSpan">restoreOverriddenClientRequest</span>();

  //  We override the requests so that we can save information on them before executing.
  common.overrideRequests(function(proto, overriddenRequest, options, callback) {

var bodyChunks = [];

if (typeof options == 'string') {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nock.interceptor" id="apidoc.module.nock.interceptor">module nock.interceptor</a></h1>


    <h2>
        <a href="#apidoc.element.nock.interceptor.interceptor" id="apidoc.element.nock.interceptor.interceptor">
        function <span class="apidocSignatureSpan">nock.</span>interceptor
        <span class="apidocSignatureSpan">(scope, uri, method, requestBody, interceptorOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Interceptor(scope, uri, method, requestBody, interceptorOptions) {
    this.scope = scope;
    this.interceptorMatchHeaders = [];
    this.method = method.toUpperCase();
    this.uri = uri;
    this._key = this.method + ' ' + scope.basePath + scope.basePathname + (typeof uri === 'string' ? '' : '/') + uri;
    this.basePath = this.scope.basePath;
    this.path = (typeof uri === 'string') ? scope.basePathname + uri : uri;

    this.baseUri = this.method + ' ' + scope.basePath + scope.basePathname;
    this.options = interceptorOptions || {};
    this.counter = 1;
    this._requestBody = requestBody;

    //  We use lower-case header field names throughout Nock.
    this.reqheaders = common.headersFieldNamesToLowerCase((scope.scopeOptions &amp;&amp; scope.scopeOptions.reqheaders) || {});
    this.badheaders = common.headersFieldsArrayToLowerCase((scope.scopeOptions &amp;&amp; scope.scopeOptions.badheaders) || []);


    this.delayInMs = 0;
    this.delayConnectionInMs = 0;

    this.optional = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nock.interceptor.prototype" id="apidoc.module.nock.interceptor.prototype">module nock.interceptor.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.nock.interceptor.prototype.basicAuth" id="apidoc.element.nock.interceptor.prototype.basicAuth">
        function <span class="apidocSignatureSpan">nock.interceptor.prototype.</span>basicAuth
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function basicAuth(options) {
    var username = options['user'];
    var password = options['pass'] || '';
    var name = 'authorization';
    var value = 'Basic ' + new Buffer(username + ':' + password).toString('base64');
    this.interceptorMatchHeaders.push({ name: name, value: value });
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
When invoked with this option, Nock will not match the request if any of the `badheaders` are present.

Basic authentication can be specified as follows:

```js
var scope = nock('http://www.example.com')
    .get('/')
    .<span class="apidocCodeKeywordSpan">basicAuth</span>({
      user: 'john',
      pass: 'doe'
    })
    .reply(200);
```

### Specifying Reply Headers
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.interceptor.prototype.delay" id="apidoc.element.nock.interceptor.prototype.delay">
        function <span class="apidocSignatureSpan">nock.interceptor.prototype.</span>delay
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function delay(opts) {
    var headDelay = 0;
    var bodyDelay = 0;
    if (_.isNumber(opts)) {
        headDelay = opts;
    } else if (_.isObject(opts)) {
        headDelay = opts.head || 0;
        bodyDelay = opts.body || 0;
    } else {
        throw new Error("Unexpected input opts" + opts);
    }

    return this.delayConnection(headDelay)
        .delayBody(bodyDelay);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
## Delay the response

You are able to specify the number of milliseconds that your reply should be delayed.

```js
nock('http://my.server.com')
 .get('/')
 .<span class="apidocCodeKeywordSpan">delay</span>(2000) // 2 seconds delay will be applied to the response header.
 .reply(200, '&lt;html&gt;&lt;/html&gt;')
```

`delay()` could also be used as

```
delay({
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.interceptor.prototype.delayBody" id="apidoc.element.nock.interceptor.prototype.delayBody">
        function <span class="apidocSignatureSpan">nock.interceptor.prototype.</span>delayBody
        <span class="apidocSignatureSpan">(ms)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function delayBody(ms) {
    this.delayInMs += ms;
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
You are able to specify the number of milliseconds that the response body should be delayed. Response header will be replied immediately
.
`delayBody(1000)` is equivalent to `delay({body: 1000})`.


```js
nock('http://my.server.com')
  .get('/')
  .<span class="apidocCodeKeywordSpan">delayBody</span>(2000) // 2 seconds
  .reply(200, '&lt;html&gt;&lt;/html&gt;')
```

NOTE: the [`'response'`](http://nodejs.org/api/http.html#http_event_response) event will occur immediately, but the [IncomingMessage
](http://nodejs.org/api/http.html#http_http_incomingmessage) not emit it's `'end'` event until after the delay.

## Delay the response
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.interceptor.prototype.delayConnection" id="apidoc.element.nock.interceptor.prototype.delayConnection">
        function <span class="apidocSignatureSpan">nock.interceptor.prototype.</span>delayConnection
        <span class="apidocSignatureSpan">(ms)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function delayConnection(ms) {
    this.delayConnectionInMs += ms;
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   } else if (_.isObject(opts)) {
       headDelay = opts.head || 0;
       bodyDelay = opts.body || 0;
   } else {
       throw new Error("Unexpected input opts" + opts);
   }

   return this.<span class="apidocCodeKeywordSpan">delayConnection</span>(headDelay)
       .delayBody(bodyDelay);
};

/**
* Delay the response body by a certain number of ms.
*
* @param {integer} ms - Number of milliseconds to wait before response is sent
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.interceptor.prototype.discard" id="apidoc.element.nock.interceptor.prototype.discard">
        function <span class="apidocSignatureSpan">nock.interceptor.prototype.</span>discard
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function discard() {
    if ((this.scope.shouldPersist() || this.counter &gt; 0) &amp;&amp; this.filePath) {
        this.body = fs.createReadStream(this.filePath);
        this.body.pause();
    }

    if (!this.scope.shouldPersist() &amp;&amp; this.counter &lt; 1) {
        this.scope.remove(this._key, this);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    req.headers = req._headers;

    interceptor.scope.emit('request', req, interceptor);

    if (typeof interceptor.errorMessage !== 'undefined') {
interceptor.interceptionCounter++;
remove(interceptor);
interceptor.<span class="apidocCodeKeywordSpan">discard</span>();

var error;
if (_.isObject(interceptor.errorMessage)) {
  error = interceptor.errorMessage;
} else {
  error = new Error(interceptor.errorMessage);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.interceptor.prototype.filteringPath" id="apidoc.element.nock.interceptor.prototype.filteringPath">
        function <span class="apidocSignatureSpan">nock.interceptor.prototype.</span>filteringPath
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function filteringPath() {
    if (_.isFunction(arguments[0])) {
        this.scope.transformFunction = arguments[0];
    }
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

This can be useful, for instance, if you have random or time-dependent data in your URL.

You can use a regexp for replacement, just like String.prototype.replace:

```js
var scope = nock('http://api.myservice.com')
                .<span class="apidocCodeKeywordSpan">filteringPath</span>(/password=[^&amp;]*/g, 'password=XXX')
                .get('/users/1?password=XXX')
                .reply(200, 'user');
```

Or you can use a function:

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.interceptor.prototype.getTotalDelay" id="apidoc.element.nock.interceptor.prototype.getTotalDelay">
        function <span class="apidocSignatureSpan">nock.interceptor.prototype.</span>getTotalDelay
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getTotalDelay() {
    return this.delayInMs + this.delayConnectionInMs;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  var error;
  if (_.isObject(interceptor.errorMessage)) {
    error = interceptor.errorMessage;
  } else {
    error = new Error(interceptor.errorMessage);
  }
  timers.setTimeout(emitError, interceptor.<span class="apidocCodeKeywordSpan">getTotalDelay</span>(), error);
  return;
}
response.statusCode = Number(interceptor.statusCode) || 200;

// Clone headers/rawHeaders to not override them when evaluating later
response.headers = _.extend({}, interceptor.headers);
response.rawHeaders = (interceptor.rawHeaders || []).slice();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.interceptor.prototype.match" id="apidoc.element.nock.interceptor.prototype.match">
        function <span class="apidocSignatureSpan">nock.interceptor.prototype.</span>match
        <span class="apidocSignatureSpan">(options, body, hostNameOnly)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function match(options, body, hostNameOnly) {
    if (debug.enabled) {
        debug('match %s, body = %s', stringify(options), stringify(body));
    }

    if (hostNameOnly) {
        return options.hostname === this.scope.urlParts.hostname;
    }

    var method = (options.method || 'GET').toUpperCase()
        , path = options.path
        , matches
        , matchKey
        , proto = options.proto;

    if (this.scope.transformPathFunction) {
        path = this.scope.transformPathFunction(path);
    }
    if (typeof(body) !== 'string') {
        body = body.toString();
    }
    if (this.scope.transformRequestBodyFunction) {
        body = this.scope.transformRequestBodyFunction(body, this._requestBody);
    }

    var checkHeaders = function(header) {
        if (_.isFunction(header.value)) {
            return header.value(options.getHeader(header.name));
        }
        return common.matchStringOrRegexp(options.getHeader(header.name), header.value);
    };

    if (!this.scope.matchHeaders.every(checkHeaders) ||
        !this.interceptorMatchHeaders.every(checkHeaders)) {
        this.scope.logger('headers don\'t match');
        return false;
    }

    var reqHeadersMatch =
        ! this.reqheaders ||
        Object.keys(this.reqheaders).every(this.reqheaderMatches.bind(this, options));

    if (!reqHeadersMatch) {
        return false;
    }

    function reqheaderContains(header) {
        return _.has(options.headers, header);
    }

    var reqContainsBadHeaders =
        this.badheaders &amp;&amp;
        _.some(this.badheaders, reqheaderContains);

    if (reqContainsBadHeaders) {
        return false;
    }

    //  If we have a filtered scope then we use it instead reconstructing
    //  the scope from the request options (proto, host and port) as these
    //  two won't necessarily match and we have to remove the scope that was
    //  matched (vs. that was defined).
    if (this.__nock_filteredScope) {
        matchKey = this.__nock_filteredScope;
    } else {
        matchKey = proto + '://' + options.host;
        if (
            options.port &amp;&amp; options.host.indexOf(':') &lt; 0 &amp;&amp;
            (options.port !== 80 || options.proto !== 'http') &amp;&amp;
            (options.port !== 443 || options.proto !== 'https')
        ) {
            matchKey += ":" + options.port;
        }
    }

    // Match query strings when using query()
    var matchQueries = true;
    var queryIndex = -1;
    var queryString;
    var queries;

    if (this.queries) {
        queryIndex = path.indexOf('?');
        queryString = (queryIndex !== -1) ? path.slice(queryIndex + 1) : '';
        queries = qs.parse(queryString);

        // Only check for query string matches if this.queries is an object
        if (_.isObject(this.queries)) {

            if(_.isFunction(this.queries)){
                matchQueries = this.queries(queries);
            }else {
                // Make sure that you have an equal number of keys. We are
                // looping through the passed query params and not the expected values
                // if the user passes fewer query params than expected but all values
                // match this will throw a false positive. Testing that the length of the
                // passed query params is equal to the length of expected keys will prevent
                // us from doing any value checking BEFORE we know if they have all the proper
                // params
                debug('this.queries: %j', this.queries);
                debug('queries: %j', queries);
                if (_.size(this.queries) !== _.size(queries)) {
                    matchQueries = false;
                } else {
                    var self = this;
                    _.forOwn(queries, function matchOneKeyVal(val, key) {
                        var expVal = self.queries[key];
                        var isMatch = true;
                        if (val === undefined || expVal === undefined) {
                        isMatch = false;
                    } else if (expVal instanceof RegExp) {
                      isMatch = c ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return '%' + c.charCodeAt(0).toString(16).toUpperCase();
});
}

function matchStringOrRegexp(target, pattern) {
var str = target &amp;&amp; target.toString ? target.toString() : target;

return pattern instanceof RegExp  ? str.<span class="apidocCodeKeywordSpan">match</span>(pattern) : str === pattern;
}

// return [newKey, newValue]
function formatQueryValue(key, value, options) {
switch (true) {
  case _.isNumber(value): // fall-though
  case _.isBoolean(value):
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.interceptor.prototype.matchHeader" id="apidoc.element.nock.interceptor.prototype.matchHeader">
        function <span class="apidocSignatureSpan">nock.interceptor.prototype.</span>matchHeader
        <span class="apidocSignatureSpan">(name, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function matchHeader(name, value) {
    this.interceptorMatchHeaders.push({ name: name, value: value });
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

## Request Headers Matching

If you need to match requests only if certain request headers match, you can.

```js
var scope = nock('http://api.myservice.com')
                .<span class="apidocCodeKeywordSpan">matchHeader</span>('accept', 'application/json')
                .get('/')
                .reply(200, {
                  data: 'hello world'
                })
```

You can also use a regexp for the header body.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.interceptor.prototype.matchIndependentOfBody" id="apidoc.element.nock.interceptor.prototype.matchIndependentOfBody">
        function <span class="apidocSignatureSpan">nock.interceptor.prototype.</span>matchIndependentOfBody
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function matchIndependentOfBody(options) {
    var method = (options.method || 'GET').toUpperCase()
        , path = options.path
        , proto = options.proto;

    if (this.scope.transformPathFunction) {
        path = this.scope.transformPathFunction(path);
    }

    var checkHeaders = function(header) {
        return options.getHeader &amp;&amp; common.matchStringOrRegexp(options.getHeader(header.name), header.value);
    };

    if (!this.scope.matchHeaders.every(checkHeaders) ||
        !this.interceptorMatchHeaders.every(checkHeaders)) {
        return false;
    }

    var matchKey = method + ' ' + proto + '://' + options.host + path;
    return this._key === matchKey;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var interceptors = interceptorsFor(options)

    if (isOn() &amp;&amp; interceptors) {
var matches = false,
    allowUnmocked = false;

matches = !! _.find(interceptors, function(interceptor) {
  return interceptor.<span class="apidocCodeKeywordSpan">matchIndependentOfBody</span>(options);
});

allowUnmocked = !! _.find(interceptors, function(interceptor) {
  return interceptor.options.allowUnmocked;
});

if (! matches &amp;&amp; allowUnmocked) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.interceptor.prototype.once" id="apidoc.element.nock.interceptor.prototype.once">
        function <span class="apidocSignatureSpan">nock.interceptor.prototype.</span>once
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function once() {
    return this.times(1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
http.get('http://zombo.com/'); // respond body "Ok"
http.get('http://zombo.com/'); // respond with zombo.com result
```

Sugar syntax

```js
nock('http://zombo.com').get('/').<span class="apidocCodeKeywordSpan">once</span>().reply(200, 'Ok'
;);
nock('http://zombo.com').get('/').twice().reply(200, 'Ok');
nock('http://zombo.com').get('/').thrice().reply(200, 'Ok');
```

## Delay the response body
You are able to specify the number of milliseconds that the response body should be delayed. Response header will be replied immediately
.
`delayBody(1000)` is equivalent to `delay({body: 1000})`.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.interceptor.prototype.optionally" id="apidoc.element.nock.interceptor.prototype.optionally">
        function <span class="apidocSignatureSpan">nock.interceptor.prototype.</span>optionally
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function optionally() {
    this.optional = true;
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
example.pendingMocks() // []
example.get("/pathA").reply(200);
example.pendingMocks() // ["GET http://example.com:80/path"]

// ...After a request to example.com/pathA:
example.pendingMocks() // []

example.get("/pathB").<span class="apidocCodeKeywordSpan">optionally</span>().reply(200);
example.pendingMocks() // []
```

## Allow __unmocked__ requests on a mocked hostname

If you need some request on the same host name to be mocked and some others to **really** go through the HTTP stack, you can use
 the `allowUnmocked` option like this:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.interceptor.prototype.query" id="apidoc.element.nock.interceptor.prototype.query">
        function <span class="apidocSignatureSpan">nock.interceptor.prototype.</span>query
        <span class="apidocSignatureSpan">(queries)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function query(queries) {
    this.queries = this.queries || {};
    // Allow all query strings to match this route
    if (queries === true) {
        this.queries = queries;
    }

    if(_.isFunction(queries)){
        this.queries = queries;
        return this;
    }

    for (var q in queries) {
        if (_.isUndefined(this.queries[q])) {
            var value = queries[q];
            var formatedPair = common.formatQueryValue(q, value, this.scope.scopeOptions);
            this.queries[formatedPair[0]] = formatedPair[1];
        }
    }

    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
## Specifying request query string

Nock understands query strings. Instead of placing the entire URL, you can specify the query part as an object:

```js
nock('http://example.com')
  .get('/users')
  .<span class="apidocCodeKeywordSpan">query</span>({name: 'pedro', surname: 'teixeira'})
  .reply(200, {results: [{id: 'pgte'}]});
```

Nock supports array-style/object-style query parameters. The encoding format matches with request module.

```js
nock('http://example.com')
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.interceptor.prototype.reply" id="apidoc.element.nock.interceptor.prototype.reply">
        function <span class="apidocSignatureSpan">nock.interceptor.prototype.</span>reply
        <span class="apidocSignatureSpan">(statusCode, body, rawHeaders)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reply(statusCode, body, rawHeaders) {
    if (arguments.length &lt;= 2 &amp;&amp; _.isFunction(statusCode)) {
        body = statusCode;
        statusCode = 200;
    }

    this.statusCode = statusCode;

    _.defaults(this.options, this.scope.scopeOptions);

    // convert rawHeaders from Array to Object
    var headers = common.headersArrayToObject(rawHeaders);

    if (this.scope._defaultReplyHeaders) {
        headers = headers || {};
        headers = mixin(this.scope._defaultReplyHeaders, headers);
    }

    if (this.scope.date) {
        headers = headers || {};
        headers['date'] = this.scope.date.toUTCString();
    }

    if (headers !== undefined) {
        this.rawHeaders = [];

        // makes sure all keys in headers are in lower case
        for (var key in headers) {
            if (headers.hasOwnProperty(key)) {
                this.rawHeaders.push(key);
                this.rawHeaders.push(headers[key]);
            }
        }

        //  We use lower-case headers throughout Nock.
        this.headers = common.headersFieldNamesToLowerCase(headers);

        debug('reply.headers:', this.headers);
        debug('reply.rawHeaders:', this.rawHeaders);
    }

    //  If the content is not encoded we may need to transform the response body.
    //  Otherwise we leave it as it is.
    if (!common.isContentEncoded(this.headers)) {
        if (body &amp;&amp; typeof(body) !== 'string' &amp;&amp;
            typeof(body) !== 'function' &amp;&amp;
            !Buffer.isBuffer(body) &amp;&amp;
            !common.isStream(body)) {
            try {
                body = stringify(body);
                if (!this.headers) {
                    this.headers = {};
                }
                if (!this.headers['content-type']) {
                    this.headers['content-type'] = 'application/json';
                }
                if (this.scope.contentLen) {
                    this.headers['content-length'] = body.length;
                }
            } catch(err) {
                throw new Error('Error encoding response body into JSON');
            }
        }
    }

    this.body = body;

    this.scope.add(this._key, this, this.scope, this.scopeOptions);
    return this.scope;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
On your test, you can setup your mocking object like this:

```js
var nock = require('nock');

var couchdb = nock('http://myapp.iriscouch.com')
                .get('/users/1')
                .<span class="apidocCodeKeywordSpan">reply</span>(200, {
                  _id: '123ABC',
                  _rev: '946B7D1C',
                  username: 'pgte',
                  email: 'pedro.teixeira@gmail.com'
                 });
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.interceptor.prototype.replyWithError" id="apidoc.element.nock.interceptor.prototype.replyWithError">
        function <span class="apidocSignatureSpan">nock.interceptor.prototype.</span>replyWithError
        <span class="apidocSignatureSpan">(errorMessage)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function replyWithError(errorMessage) {
    this.errorMessage = errorMessage;

    _.defaults(this.options, this.scope.scopeOptions);

    this.scope.add(this._key, this, this.scope, this.scopeOptions);
    return this.scope;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### Replying with errors

You can reply with an error like this:

```js
nock('http://www.google.com')
 .get('/cat-poems')
 .<span class="apidocCodeKeywordSpan">replyWithError</span>('something awful happened');
```

JSON error responses are allowed too:

```js
nock('http://www.google.com')
.get('/cat-poems')
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.interceptor.prototype.replyWithFile" id="apidoc.element.nock.interceptor.prototype.replyWithFile">
        function <span class="apidocSignatureSpan">nock.interceptor.prototype.</span>replyWithFile
        <span class="apidocSignatureSpan">(statusCode, filePath, headers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function replyWithFile(statusCode, filePath, headers) {
    if (! fs) {
        throw new Error('No fs');
    }
    var readStream = fs.createReadStream(filePath);
    readStream.pause();
    this.filePath = filePath;
    return this.reply(statusCode, readStream, headers);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

or even as a file:

```js
var scope = nock('http://myapp.iriscouch.com')
             .get('/')
             .<span class="apidocCodeKeywordSpan">replyWithFile</span>(200, __dirname + '/replies/user.json');
```

Instead of an object or a buffer you can also pass in a callback to be evaluated for the value of the response body:

```js
var scope = nock('http://www.google.com')
.filteringRequestBody(/.*/, '*')
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.interceptor.prototype.reqheaderMatches" id="apidoc.element.nock.interceptor.prototype.reqheaderMatches">
        function <span class="apidocSignatureSpan">nock.interceptor.prototype.</span>reqheaderMatches
        <span class="apidocSignatureSpan">(options, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reqheaderMatches(options, key) {
    //  We don't try to match request headers if these weren't even specified in the request.
    if (! options.headers) {
        return true;
    }

    var reqHeader = this.reqheaders[key];
    var header = options.headers[key];
    if (header &amp;&amp; (typeof header !== 'string') &amp;&amp; header.toString) {
        header = header.toString();
    }

    //  We skip 'host' header comparison unless it's available in both mock and actual request.
    //  This because 'host' may get inserted by Nock itself and then get recorder.
    //  NOTE: We use lower-case header field names throughout Nock.
    if (key === 'host' &amp;&amp;
        (_.isUndefined(header) ||
        _.isUndefined(reqHeader)))
    {
        return true;
    }

    if (reqHeader &amp;&amp; header) {
        if (_.isFunction(reqHeader)) {
            return reqHeader(header);
        } else if (common.matchStringOrRegexp(header, reqHeader)) {
            return true;
        }
    }

    debug('request header field doesn\'t match:', key, header, reqHeader);
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.interceptor.prototype.socketDelay" id="apidoc.element.nock.interceptor.prototype.socketDelay">
        function <span class="apidocSignatureSpan">nock.interceptor.prototype.</span>socketDelay
        <span class="apidocSignatureSpan">(ms)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function socketDelay(ms) {
    this.socketDelayInMs = ms;
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
## Socket timeout

You are able to specify the number of milliseconds that your connection should be idle, to simulate a socket timeout.

```js
nock('http://my.server.com')
  .get('/')
  .<span class="apidocCodeKeywordSpan">socketDelay</span>(2000) // 2 seconds
  .reply(200, '&lt;html&gt;&lt;/html&gt;')
```

To test a request like the following:

```js
req = http.request('http://my.server.com', function(res) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.interceptor.prototype.thrice" id="apidoc.element.nock.interceptor.prototype.thrice">
        function <span class="apidocSignatureSpan">nock.interceptor.prototype.</span>thrice
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function thrice() {
    return this.times(3);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

Sugar syntax

```js
nock('http://zombo.com').get('/').once().reply(200, 'Ok');
nock('http://zombo.com').get('/').twice().reply(200, 'Ok');
nock('http://zombo.com').get('/').<span class="apidocCodeKeywordSpan">thrice</span>().reply(200, 'Ok'
;);
```

## Delay the response body
You are able to specify the number of milliseconds that the response body should be delayed. Response header will be replied immediately
.
`delayBody(1000)` is equivalent to `delay({body: 1000})`.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.interceptor.prototype.times" id="apidoc.element.nock.interceptor.prototype.times">
        function <span class="apidocSignatureSpan">nock.interceptor.prototype.</span>times
        <span class="apidocSignatureSpan">(newCounter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function times(newCounter) {
    if (newCounter &lt; 1) {
        return this;
    }

    this.counter = newCounter;

    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

## Repeat response n times

You are able to specify the number of times to repeat the same response.

```js
nock('http://zombo.com').get('/').<span class="apidocCodeKeywordSpan">times</span>(4).reply(200, 'Ok'
;);

http.get('http://zombo.com/'); // respond body "Ok"
http.get('http://zombo.com/'); // respond body "Ok"
http.get('http://zombo.com/'); // respond body "Ok"
http.get('http://zombo.com/'); // respond body "Ok"
http.get('http://zombo.com/'); // respond with zombo.com result
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.interceptor.prototype.twice" id="apidoc.element.nock.interceptor.prototype.twice">
        function <span class="apidocSignatureSpan">nock.interceptor.prototype.</span>twice
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function twice() {
    return this.times(2);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
http.get('http://zombo.com/'); // respond with zombo.com result
```

Sugar syntax

```js
nock('http://zombo.com').get('/').once().reply(200, 'Ok');
nock('http://zombo.com').get('/').<span class="apidocCodeKeywordSpan">twice</span>().reply(200, 'Ok'
;);
nock('http://zombo.com').get('/').thrice().reply(200, 'Ok');
```

## Delay the response body
You are able to specify the number of milliseconds that the response body should be delayed. Response header will be replied immediately
.
`delayBody(1000)` is equivalent to `delay({body: 1000})`.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nock.recorder" id="apidoc.module.nock.recorder">module nock.recorder</a></h1>


    <h2>
        <a href="#apidoc.element.nock.recorder.clear" id="apidoc.element.nock.recorder.clear">
        function <span class="apidocSignatureSpan">nock.recorder.</span>clear
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function clear() {
  outputs = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


var record = {


setup: function () {
  recorder.restore();
  recorder.<span class="apidocCodeKeywordSpan">clear</span>();
  nock.cleanAll();
  nock.activate();
  nock.disableNetConnect();
},


start: function (fixture, options) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.recorder.play" id="apidoc.element.nock.recorder.play">
        function <span class="apidocSignatureSpan">nock.recorder.</span>play
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">play = function () {
  return outputs;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
If you just want to capture the generated code into a var as an array you can use:

```js
nock.recorder.rec({
  dont_print: true
});
// ... some HTTP calls
var nockCalls = nock.recorder.<span class="apidocCodeKeywordSpan">play</span>();
```

The `nockCalls` var will contain an array of strings representing the generated code you need.

Copy and paste that code into your tests, customize at will, and you're done!

(Remember that you should do this one test at a time).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.recorder.rec" id="apidoc.element.nock.recorder.rec">
        function <span class="apidocSignatureSpan">nock.recorder.</span>rec
        <span class="apidocSignatureSpan">(rec_options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function record(rec_options) {

  //  Set the new current recording ID and capture its value in this instance of record().
  currentRecordingId = currentRecordingId + 1;
  var thisRecordingId = currentRecordingId;

  debug('start recording', thisRecordingId, JSON.stringify(rec_options));

  //  Trying to start recording with recording already in progress implies an error
  //  in the recording configuration (double recording makes no sense and used to lead
  //  to duplicates in output)
  if(recordingInProgress) {
    throw new Error('Nock recording already in progress');
  }

  recordingInProgress = true;

  //  Originaly the parameters was a dont_print boolean flag.
  //  To keep the existing code compatible we take that case into account.
  var optionsIsObject = typeof rec_options === 'object';
  var dont_print = (typeof rec_options === 'boolean' &amp;&amp; rec_options) ||
      (optionsIsObject &amp;&amp; rec_options.dont_print);
  var output_objects = optionsIsObject &amp;&amp; rec_options.output_objects;
  var enable_reqheaders_recording = optionsIsObject &amp;&amp; rec_options.enable_reqheaders_recording;
  var logging = (optionsIsObject &amp;&amp; rec_options.logging) || console.log;
  var use_separator = true;
  if (optionsIsObject &amp;&amp; _.has(rec_options, 'use_separator')) {
    use_separator = rec_options.use_separator;
  }

  debug(thisRecordingId, 'restoring overridden requests before new overrides');
  //  To preserve backward compatibility (starting recording wasn't throwing if nock was already active)
  //  we restore any requests that may have been overridden by other parts of nock (e.g. intercept)
  //  NOTE: This is hacky as hell but it keeps the backward compatibility *and* allows correct
  //    behavior in the face of other modules also overriding ClientRequest.
  common.restoreOverriddenRequests();
  //  We restore ClientRequest as it messes with recording of modules that also override ClientRequest (e.g. xhr2)
  intercept.restoreOverriddenClientRequest();

  //  We override the requests so that we can save information on them before executing.
  common.overrideRequests(function(proto, overriddenRequest, options, callback) {

    var bodyChunks = [];

    if (typeof options == 'string') {
      var url = URL.parse(options);
      options = {
        hostname: url.hostname,
        method: 'GET',
        port: url.port,
        path: url.path
      };
    }

    // Node 0.11 https.request calls http.request -- don't want to record things
    // twice.
    if (options._recording) {
      return overriddenRequest(options, callback);
    }
    options._recording = true;

    var req = overriddenRequest(options, function(res) {

      debug(thisRecordingId, 'intercepting', proto, 'request to record');

      if (typeof options === 'string') {
        options = parse(options);
      }

      //  We put our 'end' listener to the front of the listener array.
      res.once('end', function() {
        debug(thisRecordingId, proto, 'intercepted request ended');

        var out;
        if(output_objects) {
          out = generateRequestAndResponseObject(req, bodyChunks, options, res, dataChunks);
          if(out.reqheaders) {
            //  We never record user-agent headers as they are worse than useless -
            //  they actually make testing more difficult without providing any benefit (see README)
            common.deleteHeadersField(out.reqheaders, 'user-agent');

            //  Remove request headers completely unless it was explicitly enabled by the user (see README)
            if(!enable_reqheaders_recording) {
              delete out.reqheaders;
            }
          }
        } else {
          out = generateRequestAndResponse(req, bodyChunks, options, res, dataChunks);
        }

        debug('out:', out);

        //  Check that the request was made during the current recording.
        //  If it hasn't then skip it. There is no other simple way to handle
        //  this as it depends on the timing of requests and responses. Throwing
        //  will make some recordings/unit tests faily randomly depending on how ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
This is a cool feature:

Guessing what the HTTP calls are is a mess, specially if you are introducing nock on your already-coded tests.

For these cases where you want to mock an existing live system you can record and playback the HTTP calls like this:

```js
nock.recorder.<span class="apidocCodeKeywordSpan">rec</span>();
// Some HTTP calls happen and the nock code necessary to mock
// those calls will be outputted to console
```

Recording relies on intercepting real requests and answers and then persisting them for later use.

**ATTENTION!:** when recording is enabled, nock does no validation.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nock.scope" id="apidoc.module.nock.scope">module nock.scope</a></h1>


    <h2>
        <a href="#apidoc.element.nock.scope.scope" id="apidoc.element.nock.scope.scope">
        function <span class="apidocSignatureSpan">nock.</span>scope
        <span class="apidocSignatureSpan">(basePath, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function startScope(basePath, options) {
  return new Scope(basePath, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.scope.activate" id="apidoc.element.nock.scope.activate">
        function <span class="apidocSignatureSpan">nock.scope.</span>activate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function activate() {

  if(originalClientRequest) {
    throw new Error('Nock already active');
  }

  overrideClientRequest();

  // ----- Overriding http.request and https.request:

  common.overrideRequests(function(proto, overriddenRequest, options, callback) {
    //  NOTE: overriddenRequest is already bound to its module.
    var req,
        res;

    if (typeof options === 'string') {
      options = parse(options);
    }
    options.proto = proto;

    var interceptors = interceptorsFor(options)

    if (isOn() &amp;&amp; interceptors) {
      var matches = false,
          allowUnmocked = false;

      matches = !! _.find(interceptors, function(interceptor) {
        return interceptor.matchIndependentOfBody(options);
      });

      allowUnmocked = !! _.find(interceptors, function(interceptor) {
        return interceptor.options.allowUnmocked;
      });

      if (! matches &amp;&amp; allowUnmocked) {
        if (proto === 'https') {
          var ClientRequest = http.ClientRequest;
          http.ClientRequest = originalClientRequest;
          req = overriddenRequest(options, callback);
          http.ClientRequest = ClientRequest;
        } else {
          req = overriddenRequest(options, callback);
        }
        globalEmitter.emit('no match', req);
        return req;
      }

      //  NOTE: Since we already overrode the http.ClientRequest we are in fact constructing
      //    our own OverriddenClientRequest.
      req = new http.ClientRequest(options);

      res = RequestOverrider(req, options, interceptors, remove);
      if (callback) {
        res.on('response', callback);
      }
      return req;
    } else {
      globalEmitter.emit('no match', options);
      if (isOff() || isEnabledForNetConnect(options)) {
        return overriddenRequest(options, callback);
      } else {
        var error = new NetConnectNotAllowedError(options.host, options.path);
        return new ErroringClientRequest(error);
      }
    }
  });

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var wild = {


setup: function () {
  nock.cleanAll();
  recorder.restore();
  nock.<span class="apidocCodeKeywordSpan">activate</span>();
  nock.enableNetConnect();
},


start: function () {
  return load(); //don't load anything but get correct context
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.scope.activeMocks" id="apidoc.element.nock.scope.activeMocks">
        function <span class="apidocSignatureSpan">nock.scope.</span>activeMocks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function activeMocks() {
  return _.flatten(_.map(interceptorScopes(), function(scope) {
    return scope.activeMocks();
  }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* 8.2.0
* Add changelog to the dev dependencies
* Ignore browserify-bundle.js
* Update browserify-bundle.js
* Merge pull request [#723](https://github.com/node-nock/nock/issues/723) from pimterry/optional-mocks
  Add optionally() and make isDone and pendingMocks consistent.
* Include all review markup changes in browserify-bundle
* Add .<span class="apidocCodeKeywordSpan">activeMocks</span>() to recreate previous .pendingMocks() behaviour
* Add times+optional and persist+optional tests
* Document assumption in pendingMocks()
* Clarify optional mock behaviour a little in README
* Merge pull request [#721](https://github.com/node-nock/nock/issues/721) from pimterry/removeInterceptor-from-pending
  Update PendingMocks when an interceptor is removed
* Merge pull request [#722](https://github.com/node-nock/nock/issues/722) from Ginden/no-garbage-in-npm
  Removed coverage folder from npm
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.scope.back" id="apidoc.element.nock.scope.back">
        function <span class="apidocSignatureSpan">nock.scope.</span>back
        <span class="apidocSignatureSpan">(fixtureName, options, nockedFn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Back(fixtureName, options, nockedFn) {
  if(!Back.fixtures) {
    throw new Error(  'Back requires nock.back.fixtures to be set\n' +
                      'Ex:\n' +
                      '\trequire(nock).back.fixtures = \'/path/to/fixures/\'');
  }

  if( arguments.length === 2 ) {
    nockedFn = options;
    options = {};
  }

  _mode.setup();

  var fixture = path.join(Back.fixtures, fixtureName)
    , context = _mode.start(fixture, options);


  var nockDone = function () {
    _mode.finish(fixture, options, context);
  };

  debug('context:', context);

  nockedFn.call(context, nockDone);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.scope.cleanAll" id="apidoc.element.nock.scope.cleanAll">
        function <span class="apidocSignatureSpan">nock.scope.</span>cleanAll
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cleanAll() {
  globalIntercept.removeAll();
  return module.exports;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  * [Path filtering](#path-filtering)
  * [Request Body filtering](#request-body-filtering)
  * [Request Headers Matching](#request-headers-matching)
  * [Optional Requests](#optional-requests)
  * [Allow __unmocked__ requests on a mocked hostname](#allow-__unmocked__-requests-on-a-mocked-hostname)
- [Expectations](#expectations)
  * [.isDone()](#isdone)
  * [.<span class="apidocCodeKeywordSpan">cleanAll</span>()](#cleanall)
  * [.persist()](#persist)
  * [.pendingMocks()](#pendingmocks)
  * [.activeMocks()](#activemocks)
- [Logging](#logging)
- [Restoring](#restoring)
- [Turning Nock Off (experimental!)](#turning-nock-off-experimental)
- [Enable/Disable real HTTP request](#enabledisable-real-http-request)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.scope.define" id="apidoc.element.nock.scope.define">
        function <span class="apidocSignatureSpan">nock.scope.</span>define
        <span class="apidocSignatureSpan">(nockDefs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function define(nockDefs) {

  var nocks     = [];

  nockDefs.forEach(function(nockDef) {

    var nscope     = getScopeFromDefinition(nockDef)
      , npath      = nockDef.path
      , method     = nockDef.method.toLowerCase() || "get"
      , status     = getStatusFromDefinition(nockDef)
      , rawHeaders = nockDef.rawHeaders || []
      , reqheaders = nockDef.reqheaders || {}
      , body       = nockDef.body       || ''
      , options    = nockDef.options    || {};

    //  We use request headers for both filtering (see below) and mocking.
    //  Here we are setting up mocked request headers but we don't want to
    //  be changing the user's options object so we clone it first.
    options = _.clone(options) || {};
    options.reqheaders = reqheaders;

    //  Response is not always JSON as it could be a string or binary data or
    //  even an array of binary buffers (e.g. when content is enconded)
    var response;
    if (!nockDef.response) {
      response = '';
    } else {
      response = _.isString(nockDef.response) ? tryJsonParse(nockDef.response) : nockDef.response;
    }

    var nock;
    if (body==="*") {
      nock = startScope(nscope, options).filteringRequestBody(function() {
        return "*";
      })[method](npath, "*").reply(status, response, rawHeaders);
    } else {
      nock = startScope(nscope, options);
      //  If request headers were specified filter by them.
      if (_.size(reqheaders) &gt; 0) {
        for (var k in reqheaders) {
          nock.matchHeader(k, reqheaders[k]);
        }
      }
      if (nockDef.filteringRequestBody) {
        nock.filteringRequestBody(nockDef.filteringRequestBody);
      }
      nock.intercept(npath, method, body).reply(status, response, rawHeaders);
    }

    nocks.push(nock);

  });

  return nocks;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return body.replace(/(timestamp):([0-9]+)/g, function(match, key, value) {
    return key + ':' + recordedTimestamp;
  });
};
});
```

Alternatively, if you need to pre-process the captured nock definitions before using them (e.g. to add scope filtering) then you
 can use `nock.loadDefs(path)` and `nock.<span class="apidocCodeKeywordSpan">define</span>(nockDefs)`. Shown here is scope filtering
 for Dropbox node module which constantly changes the subdomain to which it sends the requests:

```js
//  Pre-process the nock definitions as scope filtering has to be defined before the nocks are defined (due to its very hacky nature
).
var nockDefs = nock.loadDefs(pathToJson);
nockDefs.forEach(function(def) {
//  Do something with the definition object e.g. scope filtering.
def.options = def.options || {};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.scope.disableNetConnect" id="apidoc.element.nock.scope.disableNetConnect">
        function <span class="apidocSignatureSpan">nock.scope.</span>disableNetConnect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function disableNetConnect() {
  allowNetConnect = undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
# Enable/Disable real HTTP request

As default, if you do not mock a host, a real HTTP request will do, but sometimes you should not permit real HTTP request, so...

For disabling real http requests.

```js
nock.<span class="apidocCodeKeywordSpan">disableNetConnect</span>();
```

So, if you try to request any host not 'nocked', it will thrown an `NetConnectNotAllowedError`.

```js
nock.disableNetConnect();
var req = http.get('http://google.com/');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.scope.enableNetConnect" id="apidoc.element.nock.scope.enableNetConnect">
        function <span class="apidocSignatureSpan">nock.scope.</span>enableNetConnect
        <span class="apidocSignatureSpan">(matcher)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function enableNetConnect(matcher) {
  if (_.isString(matcher)) {
    allowNetConnect = new RegExp(matcher);
  } else if (_.isObject(matcher) &amp;&amp; _.isFunction(matcher.test)) {
    allowNetConnect = matcher;
  } else {
    allowNetConnect = /.*/;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// This code will log a NetConnectNotAllowedError with message:
// Nock: Not allow net connect for "google.com:80"
```

For enabling real HTTP requests (the default behaviour).

```js
nock.<span class="apidocCodeKeywordSpan">enableNetConnect</span>();
```

You could allow real HTTP request for certain host names by providing a string or a regular expression for the hostname:

```js
// using a string
nock.enableNetConnect('amazon.com');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.scope.isActive" id="apidoc.element.nock.scope.isActive">
        function <span class="apidocSignatureSpan">nock.scope.</span>isActive
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isActive() {

  //  If ClientRequest has been overwritten by Nock then originalClientRequest is not undefined.
  //  This means that Nock has been activated.
  return !_.isUndefined(originalClientRequest);

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.scope.isDone" id="apidoc.element.nock.scope.isDone">
        function <span class="apidocSignatureSpan">nock.scope.</span>isDone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isDone() {
  return _.every(interceptorScopes(), function(scope) {
    return scope.isDone();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  * [Scope filtering](#scope-filtering)
  * [Path filtering](#path-filtering)
  * [Request Body filtering](#request-body-filtering)
  * [Request Headers Matching](#request-headers-matching)
  * [Optional Requests](#optional-requests)
  * [Allow __unmocked__ requests on a mocked hostname](#allow-__unmocked__-requests-on-a-mocked-hostname)
- [Expectations](#expectations)
  * [.<span class="apidocCodeKeywordSpan">isDone</span>()](#isdone)
  * [.cleanAll()](#cleanall)
  * [.persist()](#persist)
  * [.pendingMocks()](#pendingmocks)
  * [.activeMocks()](#activemocks)
- [Logging](#logging)
- [Restoring](#restoring)
- [Turning Nock Off (experimental!)](#turning-nock-off-experimental)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.scope.load" id="apidoc.element.nock.scope.load">
        function <span class="apidocSignatureSpan">nock.scope.</span>load
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function load(path) {
  return define(loadDefs(path));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `path` - the path of the call (e.g. `'/pgte/nock'`)
* `body` - the body of the call, if any
* `status` - the HTTP status of the reply (e.g. `200`)
* `response` - the body of the reply which can be a JSON, string, hex string representing binary buffers or an array of such hex
 strings (when handling `content-encoded` in reply header)
* `headers` - the headers of the reply
* `reqheader` - the headers of the request

If you save this as a JSON file, you can load them directly through `nock.<span class="apidocCodeKeywordSpan">load</span>(path)`.
Then you can post-process them before using them in the tests for example to add them request body filtering (shown here fixing
timestamps to match the ones captured during recording):

```js
nocks = nock.load(pathToJson);
nocks.forEach(function(nock) {
nock.filteringRequestBody = function(body, aRecordedBody) {
  if (typeof(body) !== 'string' || typeof(aRecordedBody) !== 'string') {
    return body;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.scope.loadDefs" id="apidoc.element.nock.scope.loadDefs">
        function <span class="apidocSignatureSpan">nock.scope.</span>loadDefs
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function loadDefs(path) {
  if (! fs) {
    throw new Error('No fs');
  }

  var contents = fs.readFileSync(path);
  return JSON.parse(contents);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return body.replace(/(timestamp):([0-9]+)/g, function(match, key, value) {
    return key + ':' + recordedTimestamp;
  });
};
});
```

Alternatively, if you need to pre-process the captured nock definitions before using them (e.g. to add scope filtering) then you
 can use `nock.<span class="apidocCodeKeywordSpan">loadDefs</span>(path)` and `nock.define(nockDefs)`. Shown here is scope filtering
 for Dropbox node module which constantly changes the subdomain to which it sends the requests:

```js
//  Pre-process the nock definitions as scope filtering has to be defined before the nocks are defined (due to its very hacky nature
).
var nockDefs = nock.loadDefs(pathToJson);
nockDefs.forEach(function(def) {
//  Do something with the definition object e.g. scope filtering.
def.options = def.options || {};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.scope.pendingMocks" id="apidoc.element.nock.scope.pendingMocks">
        function <span class="apidocSignatureSpan">nock.scope.</span>pendingMocks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function pendingMocks() {
  return _.flatten(_.map(interceptorScopes(), function(scope) {
    return scope.pendingMocks();
  }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* 8.2.0
* Add changelog to the dev dependencies
* Ignore browserify-bundle.js
* Update browserify-bundle.js
* Merge pull request [#723](https://github.com/node-nock/nock/issues/723) from pimterry/optional-mocks
  Add optionally() and make isDone and pendingMocks consistent.
* Include all review markup changes in browserify-bundle
* Add .activeMocks() to recreate previous .<span class="apidocCodeKeywordSpan">pendingMocks</span>() behaviour
* Add times+optional and persist+optional tests
* Document assumption in pendingMocks()
* Clarify optional mock behaviour a little in README
* Merge pull request [#721](https://github.com/node-nock/nock/issues/721) from pimterry/removeInterceptor-from-pending
  Update PendingMocks when an interceptor is removed
* Merge pull request [#722](https://github.com/node-nock/nock/issues/722) from Ginden/no-garbage-in-npm
  Removed coverage folder from npm
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.scope.removeInterceptor" id="apidoc.element.nock.scope.removeInterceptor">
        function <span class="apidocSignatureSpan">nock.scope.</span>removeInterceptor
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function removeInterceptor(options) {
  var baseUrl, key, method, proto;
  if (options instanceof Interceptor) {
    baseUrl = options.basePath;
    key = options._key;
  } else {
    proto = options.proto ? options.proto : 'http';

    common.normalizeRequestOptions(options);
    baseUrl = proto + '://' + options.host;
    method = options.method &amp;&amp; options.method.toUpperCase() || 'GET';
    key = method + ' ' + baseUrl + (options.path || '/');
  }

  if (allInterceptors[baseUrl] &amp;&amp; allInterceptors[baseUrl].scopes.length &gt; 0) {
    if (key) {
      for (var i = 0; i &lt; allInterceptors[baseUrl].scopes.length; i++) {
        var interceptor = allInterceptors[baseUrl].scopes[i];
        if (interceptor._key === key) {
          allInterceptors[baseUrl].scopes.splice(i, 1);
          interceptor.scope.remove(key, interceptor);
          break;
        }
      }
    } else {
      allInterceptors[baseUrl].scopes.length = 0;
    }

    return true;
  }

  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- [Enable/Disable real HTTP request](#enabledisable-real-http-request)
- [Recording](#recording)
* [`dont_print` option](#dont_print-option)
* [`output_objects` option](#output_objects-option)
* [`enable_reqheaders_recording` option](#enable_reqheaders_recording-option)
* [`logging` option](#logging-option)
* [`use_separator` option](#use_separator-option)
* [.<span class="apidocCodeKeywordSpan">removeInterceptor</span>()](#removeinterceptor)
- [Events](#events)
* [Global no match event](#global-no-match-event)
- [Nock Back](#nock-back)
* [Setup](#setup)
  + [Options](#options)
* [Usage](#usage)
  + [Options](#options-1)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.scope.restore" id="apidoc.element.nock.scope.restore">
        function <span class="apidocSignatureSpan">nock.scope.</span>restore
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function restore() {
  debug(currentRecordingId, 'restoring all the overridden http/https properties');

  common.restoreOverriddenRequests();
  intercept.restoreOverriddenClientRequest();
  recordingInProgress = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

# Restoring

You can restore the HTTP interceptor to the normal unmocked behaviour by calling:

```js
nock.<span class="apidocCodeKeywordSpan">restore</span>();
```
**note**: restore does not clear the interceptor list. Use [nock.cleanAll()](#cleanall) if you expect the interceptor list to be
 empty.

# Turning Nock Off (experimental!)

You can bypass Nock completely by setting `NOCK_OFF` environment variable to `"true"`.
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nock.socket" id="apidoc.module.nock.socket">module nock.socket</a></h1>


    <h2>
        <a href="#apidoc.element.nock.socket.socket" id="apidoc.element.nock.socket.socket">
        function <span class="apidocSignatureSpan">nock.</span>socket
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Socket(options) {
  if (!(this instanceof Socket)) {
    return new Socket(options);
  }

  EventEmitter.apply(this);

  options = options || {};

  if (options.proto === 'https') {
    this.authorized = true;
  }

  this.writable = true;
  this.readable = true;
  this.destroyed = false;

  this.setNoDelay = noop;
  this.setKeepAlive = noop;
  this.resume = noop;

  // totalDelay that has already been applied to the current
  // request/connection, timeout error will be generated if
  // it is timed-out.
  this.totalDelayMs = 0;
  // Maximum allowed delay. Null means unlimited.
  this.timeoutMs = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.socket.super_" id="apidoc.element.nock.socket.super_">
        function <span class="apidocSignatureSpan">nock.socket.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nock.socket.prototype" id="apidoc.module.nock.socket.prototype">module nock.socket.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.nock.socket.prototype.applyDelay" id="apidoc.element.nock.socket.prototype.applyDelay">
        function <span class="apidocSignatureSpan">nock.socket.prototype.</span>applyDelay
        <span class="apidocSignatureSpan">(delayMs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function applyDelay(delayMs) {
  this.totalDelayMs += delayMs;

  if (this.timeoutMs &amp;&amp; this.totalDelayMs &gt; this.timeoutMs) {
    debug('socket timeout');
    if (this.timeoutFunction) {
      this.timeoutFunction();
    }
    else {
      this.emit('timeout');
    }
  }

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      process.nextTick(respond);

      function respond() {

if (aborted) { return; }

if (interceptor.socketDelayInMs &amp;&amp; interceptor.socketDelayInMs &gt; 0) {
  req.socket.<span class="apidocCodeKeywordSpan">applyDelay</span>(interceptor.socketDelayInMs);
}

if (interceptor.delayConnectionInMs &amp;&amp; interceptor.delayConnectionInMs &gt; 0) {
  setTimeout(_respond, interceptor.delayConnectionInMs);
} else {
  _respond();
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.socket.prototype.destroy" id="apidoc.element.nock.socket.prototype.destroy">
        function <span class="apidocSignatureSpan">nock.socket.prototype.</span>destroy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function destroy() {
  this.destroyed = true;
  this.readable = this.writable = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (!ended) {
    end();
  }
  var err = new Error();
  err.code = 'aborted';
  response.emit('close', err);

  req.socket.<span class="apidocCodeKeywordSpan">destroy</span>();

  req.emit('abort');

  var connResetError = new Error('socket hang up');
  connResetError.code = 'ECONNRESET';
  emitError(connResetError);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.socket.prototype.getPeerCertificate" id="apidoc.element.nock.socket.prototype.getPeerCertificate">
        function <span class="apidocSignatureSpan">nock.socket.prototype.</span>getPeerCertificate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getPeerCertificate() {
  return new Buffer((Math.random() * 10000 + Date.now()).toString()).toString('base64');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nock.socket.prototype.setTimeout" id="apidoc.element.nock.socket.prototype.setTimeout">
        function <span class="apidocSignatureSpan">nock.socket.prototype.</span>setTimeout
        <span class="apidocSignatureSpan">(timeoutMs, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setTimeout(timeoutMs, fn) {
  this.timeoutMs = timeoutMs;
  this.timeoutFunction = fn;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

To test a request like the following:

```js
req = http.request('http://my.server.com', function(res) {
  ...
});
req.<span class="apidocCodeKeywordSpan">setTimeout</span>(1000, function() {
  req.abort();
});
req.end();
```

NOTE: the timeout will be fired immediately, and will not leave the simulated connection idle for the specified period of time.
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>